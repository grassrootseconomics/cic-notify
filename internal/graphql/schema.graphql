schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "account_type"
"""
type account_type {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): accounts_aggregate!
  value: String!
}

"""
aggregated selection of "account_type"
"""
type account_type_aggregate {
  aggregate: account_type_aggregate_fields
  nodes: [account_type!]!
}

"""
aggregate fields of "account_type"
"""
type account_type_aggregate_fields {
  count(columns: [account_type_select_column!], distinct: Boolean): Int!
  max: account_type_max_fields
  min: account_type_min_fields
}

"""
Boolean expression to filter rows from the table "account_type". All fields are combined with a logical 'AND'.
"""
input account_type_bool_exp {
  _and: [account_type_bool_exp!]
  _not: account_type_bool_exp
  _or: [account_type_bool_exp!]
  accounts: accounts_bool_exp
  accounts_aggregate: accounts_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "account_type"
"""
enum account_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  account_type_pkey
}

enum account_type_enum {
  CUSTODIAL_BUSINESS
  CUSTODIAL_COMMUNITY
  CUSTODIAL_PERSONAL
  CUSTODIAL_SYSTEM
  NON_CUSTODIAL_BUSINESS
  NON_CUSTODIAL_COMMUNITY
  NON_CUSTODIAL_PERSONAL
  NON_CUSTODIAL_SYSTEM
}

"""
Boolean expression to compare columns of type "account_type_enum". All fields are combined with logical 'AND'.
"""
input account_type_enum_comparison_exp {
  _eq: account_type_enum
  _in: [account_type_enum!]
  _is_null: Boolean
  _neq: account_type_enum
  _nin: [account_type_enum!]
}

"""
input type for inserting data into table "account_type"
"""
input account_type_insert_input {
  accounts: accounts_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type account_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type account_type_min_fields {
  value: String
}

"""
response of any mutation on the table "account_type"
"""
type account_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [account_type!]!
}

"""
input type for inserting object relation for remote table "account_type"
"""
input account_type_obj_rel_insert_input {
  data: account_type_insert_input!

  """upsert condition"""
  on_conflict: account_type_on_conflict
}

"""
on_conflict condition type for table "account_type"
"""
input account_type_on_conflict {
  constraint: account_type_constraint!
  update_columns: [account_type_update_column!]! = []
  where: account_type_bool_exp
}

"""Ordering options when selecting data from "account_type"."""
input account_type_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: account_type"""
input account_type_pk_columns_input {
  value: String!
}

"""
select columns of table "account_type"
"""
enum account_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "account_type"
"""
input account_type_set_input {
  value: String
}

"""
Streaming cursor of the table "account_type"
"""
input account_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: account_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input account_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "account_type"
"""
enum account_type_update_column {
  """column name"""
  value
}

input account_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: account_type_set_input

  """filter the rows which have to be updated"""
  where: account_type_bool_exp!
}

"""
columns and relationships of "accounts"
"""
type accounts {
  """An object relationship"""
  accountTypeByAccountType: account_type!
  account_type: account_type_enum!
  blockchain_address: String!
  created_at: timestamp!
  id: Int!

  """An object relationship"""
  marketplace: marketplaces

  """An array relationship"""
  services_ratings(
    """distinct select on columns"""
    distinct_on: [services_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_ratings_order_by!]

    """filter the rows returned"""
    where: services_ratings_bool_exp
  ): [services_ratings!]!

  """An aggregate relationship"""
  services_ratings_aggregate(
    """distinct select on columns"""
    distinct_on: [services_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_ratings_order_by!]

    """filter the rows returned"""
    where: services_ratings_bool_exp
  ): services_ratings_aggregate!

  """An array relationship"""
  tills(
    """distinct select on columns"""
    distinct_on: [till_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [till_order_by!]

    """filter the rows returned"""
    where: till_bool_exp
  ): [till!]!

  """An aggregate relationship"""
  tills_aggregate(
    """distinct select on columns"""
    distinct_on: [till_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [till_order_by!]

    """filter the rows returned"""
    where: till_bool_exp
  ): till_aggregate!

  """An object relationship"""
  user: users!
  user_identifier: Int!

  """An array relationship"""
  voucher_backers(
    """distinct select on columns"""
    distinct_on: [voucher_backers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_backers_order_by!]

    """filter the rows returned"""
    where: voucher_backers_bool_exp
  ): [voucher_backers!]!

  """An aggregate relationship"""
  voucher_backers_aggregate(
    """distinct select on columns"""
    distinct_on: [voucher_backers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_backers_order_by!]

    """filter the rows returned"""
    where: voucher_backers_bool_exp
  ): voucher_backers_aggregate!

  """An array relationship"""
  voucher_certifications(
    """distinct select on columns"""
    distinct_on: [voucher_certifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_certifications_order_by!]

    """filter the rows returned"""
    where: voucher_certifications_bool_exp
  ): [voucher_certifications!]!

  """An aggregate relationship"""
  voucher_certifications_aggregate(
    """distinct select on columns"""
    distinct_on: [voucher_certifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_certifications_order_by!]

    """filter the rows returned"""
    where: voucher_certifications_bool_exp
  ): voucher_certifications_aggregate!

  """An array relationship"""
  vpas(
    """distinct select on columns"""
    distinct_on: [vpa_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vpa_order_by!]

    """filter the rows returned"""
    where: vpa_bool_exp
  ): [vpa!]!

  """An aggregate relationship"""
  vpas_aggregate(
    """distinct select on columns"""
    distinct_on: [vpa_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vpa_order_by!]

    """filter the rows returned"""
    where: vpa_bool_exp
  ): vpa_aggregate!
}

"""
aggregated selection of "accounts"
"""
type accounts_aggregate {
  aggregate: accounts_aggregate_fields
  nodes: [accounts!]!
}

input accounts_aggregate_bool_exp {
  count: accounts_aggregate_bool_exp_count
}

input accounts_aggregate_bool_exp_count {
  arguments: [accounts_select_column!]
  distinct: Boolean
  filter: accounts_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "accounts"
"""
type accounts_aggregate_fields {
  avg: accounts_avg_fields
  count(columns: [accounts_select_column!], distinct: Boolean): Int!
  max: accounts_max_fields
  min: accounts_min_fields
  stddev: accounts_stddev_fields
  stddev_pop: accounts_stddev_pop_fields
  stddev_samp: accounts_stddev_samp_fields
  sum: accounts_sum_fields
  var_pop: accounts_var_pop_fields
  var_samp: accounts_var_samp_fields
  variance: accounts_variance_fields
}

"""
order by aggregate values of table "accounts"
"""
input accounts_aggregate_order_by {
  avg: accounts_avg_order_by
  count: order_by
  max: accounts_max_order_by
  min: accounts_min_order_by
  stddev: accounts_stddev_order_by
  stddev_pop: accounts_stddev_pop_order_by
  stddev_samp: accounts_stddev_samp_order_by
  sum: accounts_sum_order_by
  var_pop: accounts_var_pop_order_by
  var_samp: accounts_var_samp_order_by
  variance: accounts_variance_order_by
}

"""
input type for inserting array relation for remote table "accounts"
"""
input accounts_arr_rel_insert_input {
  data: [accounts_insert_input!]!

  """upsert condition"""
  on_conflict: accounts_on_conflict
}

"""aggregate avg on columns"""
type accounts_avg_fields {
  id: Float
  user_identifier: Float
}

"""
order by avg() on columns of table "accounts"
"""
input accounts_avg_order_by {
  id: order_by
  user_identifier: order_by
}

"""
Boolean expression to filter rows from the table "accounts". All fields are combined with a logical 'AND'.
"""
input accounts_bool_exp {
  _and: [accounts_bool_exp!]
  _not: accounts_bool_exp
  _or: [accounts_bool_exp!]
  accountTypeByAccountType: account_type_bool_exp
  account_type: account_type_enum_comparison_exp
  blockchain_address: String_comparison_exp
  created_at: timestamp_comparison_exp
  id: Int_comparison_exp
  marketplace: marketplaces_bool_exp
  services_ratings: services_ratings_bool_exp
  services_ratings_aggregate: services_ratings_aggregate_bool_exp
  tills: till_bool_exp
  tills_aggregate: till_aggregate_bool_exp
  user: users_bool_exp
  user_identifier: Int_comparison_exp
  voucher_backers: voucher_backers_bool_exp
  voucher_backers_aggregate: voucher_backers_aggregate_bool_exp
  voucher_certifications: voucher_certifications_bool_exp
  voucher_certifications_aggregate: voucher_certifications_aggregate_bool_exp
  vpas: vpa_bool_exp
  vpas_aggregate: vpa_aggregate_bool_exp
}

"""
unique or primary key constraints on table "accounts"
"""
enum accounts_constraint {
  """
  unique or primary key constraint on columns "blockchain_address"
  """
  accounts_blockchain_address_key

  """
  unique or primary key constraint on columns "id"
  """
  accounts_pkey
}

"""
input type for incrementing numeric columns in table "accounts"
"""
input accounts_inc_input {
  user_identifier: Int
}

"""
input type for inserting data into table "accounts"
"""
input accounts_insert_input {
  accountTypeByAccountType: account_type_obj_rel_insert_input
  account_type: account_type_enum
  blockchain_address: String
  created_at: timestamp
  marketplace: marketplaces_obj_rel_insert_input
  services_ratings: services_ratings_arr_rel_insert_input
  tills: till_arr_rel_insert_input
  user: users_obj_rel_insert_input
  user_identifier: Int
  voucher_backers: voucher_backers_arr_rel_insert_input
  voucher_certifications: voucher_certifications_arr_rel_insert_input
  vpas: vpa_arr_rel_insert_input
}

"""aggregate max on columns"""
type accounts_max_fields {
  blockchain_address: String
  created_at: timestamp
  id: Int
  user_identifier: Int
}

"""
order by max() on columns of table "accounts"
"""
input accounts_max_order_by {
  blockchain_address: order_by
  created_at: order_by
  id: order_by
  user_identifier: order_by
}

"""aggregate min on columns"""
type accounts_min_fields {
  blockchain_address: String
  created_at: timestamp
  id: Int
  user_identifier: Int
}

"""
order by min() on columns of table "accounts"
"""
input accounts_min_order_by {
  blockchain_address: order_by
  created_at: order_by
  id: order_by
  user_identifier: order_by
}

"""
response of any mutation on the table "accounts"
"""
type accounts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [accounts!]!
}

"""
input type for inserting object relation for remote table "accounts"
"""
input accounts_obj_rel_insert_input {
  data: accounts_insert_input!

  """upsert condition"""
  on_conflict: accounts_on_conflict
}

"""
on_conflict condition type for table "accounts"
"""
input accounts_on_conflict {
  constraint: accounts_constraint!
  update_columns: [accounts_update_column!]! = []
  where: accounts_bool_exp
}

"""Ordering options when selecting data from "accounts"."""
input accounts_order_by {
  accountTypeByAccountType: account_type_order_by
  account_type: order_by
  blockchain_address: order_by
  created_at: order_by
  id: order_by
  marketplace: marketplaces_order_by
  services_ratings_aggregate: services_ratings_aggregate_order_by
  tills_aggregate: till_aggregate_order_by
  user: users_order_by
  user_identifier: order_by
  voucher_backers_aggregate: voucher_backers_aggregate_order_by
  voucher_certifications_aggregate: voucher_certifications_aggregate_order_by
  vpas_aggregate: vpa_aggregate_order_by
}

"""primary key columns input for table: accounts"""
input accounts_pk_columns_input {
  id: Int!
}

"""
select columns of table "accounts"
"""
enum accounts_select_column {
  """column name"""
  account_type

  """column name"""
  blockchain_address

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  user_identifier
}

"""
input type for updating data in table "accounts"
"""
input accounts_set_input {
  account_type: account_type_enum
  blockchain_address: String
  created_at: timestamp
  user_identifier: Int
}

"""aggregate stddev on columns"""
type accounts_stddev_fields {
  id: Float
  user_identifier: Float
}

"""
order by stddev() on columns of table "accounts"
"""
input accounts_stddev_order_by {
  id: order_by
  user_identifier: order_by
}

"""aggregate stddev_pop on columns"""
type accounts_stddev_pop_fields {
  id: Float
  user_identifier: Float
}

"""
order by stddev_pop() on columns of table "accounts"
"""
input accounts_stddev_pop_order_by {
  id: order_by
  user_identifier: order_by
}

"""aggregate stddev_samp on columns"""
type accounts_stddev_samp_fields {
  id: Float
  user_identifier: Float
}

"""
order by stddev_samp() on columns of table "accounts"
"""
input accounts_stddev_samp_order_by {
  id: order_by
  user_identifier: order_by
}

"""
Streaming cursor of the table "accounts"
"""
input accounts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: accounts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input accounts_stream_cursor_value_input {
  account_type: account_type_enum
  blockchain_address: String
  created_at: timestamp
  id: Int
  user_identifier: Int
}

"""aggregate sum on columns"""
type accounts_sum_fields {
  id: Int
  user_identifier: Int
}

"""
order by sum() on columns of table "accounts"
"""
input accounts_sum_order_by {
  id: order_by
  user_identifier: order_by
}

"""
update columns of table "accounts"
"""
enum accounts_update_column {
  """column name"""
  account_type

  """column name"""
  blockchain_address

  """column name"""
  created_at

  """column name"""
  user_identifier
}

input accounts_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: accounts_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: accounts_set_input

  """filter the rows which have to be updated"""
  where: accounts_bool_exp!
}

"""aggregate var_pop on columns"""
type accounts_var_pop_fields {
  id: Float
  user_identifier: Float
}

"""
order by var_pop() on columns of table "accounts"
"""
input accounts_var_pop_order_by {
  id: order_by
  user_identifier: order_by
}

"""aggregate var_samp on columns"""
type accounts_var_samp_fields {
  id: Float
  user_identifier: Float
}

"""
order by var_samp() on columns of table "accounts"
"""
input accounts_var_samp_order_by {
  id: order_by
  user_identifier: order_by
}

"""aggregate variance on columns"""
type accounts_variance_fields {
  id: Float
  user_identifier: Float
}

"""
order by variance() on columns of table "accounts"
"""
input accounts_variance_order_by {
  id: order_by
  user_identifier: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"""
columns and relationships of "gender_type"
"""
type gender_type {
  """An array relationship"""
  personal_informations(
    """distinct select on columns"""
    distinct_on: [personal_information_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [personal_information_order_by!]

    """filter the rows returned"""
    where: personal_information_bool_exp
  ): [personal_information!]!

  """An aggregate relationship"""
  personal_informations_aggregate(
    """distinct select on columns"""
    distinct_on: [personal_information_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [personal_information_order_by!]

    """filter the rows returned"""
    where: personal_information_bool_exp
  ): personal_information_aggregate!
  value: String!
}

"""
aggregated selection of "gender_type"
"""
type gender_type_aggregate {
  aggregate: gender_type_aggregate_fields
  nodes: [gender_type!]!
}

"""
aggregate fields of "gender_type"
"""
type gender_type_aggregate_fields {
  count(columns: [gender_type_select_column!], distinct: Boolean): Int!
  max: gender_type_max_fields
  min: gender_type_min_fields
}

"""
Boolean expression to filter rows from the table "gender_type". All fields are combined with a logical 'AND'.
"""
input gender_type_bool_exp {
  _and: [gender_type_bool_exp!]
  _not: gender_type_bool_exp
  _or: [gender_type_bool_exp!]
  personal_informations: personal_information_bool_exp
  personal_informations_aggregate: personal_information_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "gender_type"
"""
enum gender_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  gender_type_pkey
}

enum gender_type_enum {
  FEMALE
  MALE
}

"""
Boolean expression to compare columns of type "gender_type_enum". All fields are combined with logical 'AND'.
"""
input gender_type_enum_comparison_exp {
  _eq: gender_type_enum
  _in: [gender_type_enum!]
  _is_null: Boolean
  _neq: gender_type_enum
  _nin: [gender_type_enum!]
}

"""
input type for inserting data into table "gender_type"
"""
input gender_type_insert_input {
  personal_informations: personal_information_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type gender_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type gender_type_min_fields {
  value: String
}

"""
response of any mutation on the table "gender_type"
"""
type gender_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [gender_type!]!
}

"""
input type for inserting object relation for remote table "gender_type"
"""
input gender_type_obj_rel_insert_input {
  data: gender_type_insert_input!

  """upsert condition"""
  on_conflict: gender_type_on_conflict
}

"""
on_conflict condition type for table "gender_type"
"""
input gender_type_on_conflict {
  constraint: gender_type_constraint!
  update_columns: [gender_type_update_column!]! = []
  where: gender_type_bool_exp
}

"""Ordering options when selecting data from "gender_type"."""
input gender_type_order_by {
  personal_informations_aggregate: personal_information_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: gender_type"""
input gender_type_pk_columns_input {
  value: String!
}

"""
select columns of table "gender_type"
"""
enum gender_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "gender_type"
"""
input gender_type_set_input {
  value: String
}

"""
Streaming cursor of the table "gender_type"
"""
input gender_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: gender_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input gender_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "gender_type"
"""
enum gender_type_update_column {
  """column name"""
  value
}

input gender_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: gender_type_set_input

  """filter the rows which have to be updated"""
  where: gender_type_bool_exp!
}

"""
columns and relationships of "interface_type"
"""
type interface_type {
  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
  value: String!
}

"""
aggregated selection of "interface_type"
"""
type interface_type_aggregate {
  aggregate: interface_type_aggregate_fields
  nodes: [interface_type!]!
}

"""
aggregate fields of "interface_type"
"""
type interface_type_aggregate_fields {
  count(columns: [interface_type_select_column!], distinct: Boolean): Int!
  max: interface_type_max_fields
  min: interface_type_min_fields
}

"""
Boolean expression to filter rows from the table "interface_type". All fields are combined with a logical 'AND'.
"""
input interface_type_bool_exp {
  _and: [interface_type_bool_exp!]
  _not: interface_type_bool_exp
  _or: [interface_type_bool_exp!]
  users: users_bool_exp
  users_aggregate: users_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "interface_type"
"""
enum interface_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  interface_type_pkey
}

enum interface_type_enum {
  APP
  TELEGRAM
  USSD
}

"""
Boolean expression to compare columns of type "interface_type_enum". All fields are combined with logical 'AND'.
"""
input interface_type_enum_comparison_exp {
  _eq: interface_type_enum
  _in: [interface_type_enum!]
  _is_null: Boolean
  _neq: interface_type_enum
  _nin: [interface_type_enum!]
}

"""
input type for inserting data into table "interface_type"
"""
input interface_type_insert_input {
  users: users_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type interface_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type interface_type_min_fields {
  value: String
}

"""
response of any mutation on the table "interface_type"
"""
type interface_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [interface_type!]!
}

"""
input type for inserting object relation for remote table "interface_type"
"""
input interface_type_obj_rel_insert_input {
  data: interface_type_insert_input!

  """upsert condition"""
  on_conflict: interface_type_on_conflict
}

"""
on_conflict condition type for table "interface_type"
"""
input interface_type_on_conflict {
  constraint: interface_type_constraint!
  update_columns: [interface_type_update_column!]! = []
  where: interface_type_bool_exp
}

"""Ordering options when selecting data from "interface_type"."""
input interface_type_order_by {
  users_aggregate: users_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: interface_type"""
input interface_type_pk_columns_input {
  value: String!
}

"""
select columns of table "interface_type"
"""
enum interface_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "interface_type"
"""
input interface_type_set_input {
  value: String
}

"""
Streaming cursor of the table "interface_type"
"""
input interface_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: interface_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input interface_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "interface_type"
"""
enum interface_type_update_column {
  """column name"""
  value
}

input interface_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: interface_type_set_input

  """filter the rows which have to be updated"""
  where: interface_type_bool_exp!
}

"""
columns and relationships of "marketplaces"
"""
type marketplaces {
  account: Int!

  """An object relationship"""
  accountByAccount: accounts!
  created_at: timestamp!
  id: Int!
  marketplace_name: String!

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!
}

"""
aggregated selection of "marketplaces"
"""
type marketplaces_aggregate {
  aggregate: marketplaces_aggregate_fields
  nodes: [marketplaces!]!
}

"""
aggregate fields of "marketplaces"
"""
type marketplaces_aggregate_fields {
  avg: marketplaces_avg_fields
  count(columns: [marketplaces_select_column!], distinct: Boolean): Int!
  max: marketplaces_max_fields
  min: marketplaces_min_fields
  stddev: marketplaces_stddev_fields
  stddev_pop: marketplaces_stddev_pop_fields
  stddev_samp: marketplaces_stddev_samp_fields
  sum: marketplaces_sum_fields
  var_pop: marketplaces_var_pop_fields
  var_samp: marketplaces_var_samp_fields
  variance: marketplaces_variance_fields
}

"""aggregate avg on columns"""
type marketplaces_avg_fields {
  account: Float
  id: Float
}

"""
Boolean expression to filter rows from the table "marketplaces". All fields are combined with a logical 'AND'.
"""
input marketplaces_bool_exp {
  _and: [marketplaces_bool_exp!]
  _not: marketplaces_bool_exp
  _or: [marketplaces_bool_exp!]
  account: Int_comparison_exp
  accountByAccount: accounts_bool_exp
  created_at: timestamp_comparison_exp
  id: Int_comparison_exp
  marketplace_name: String_comparison_exp
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
}

"""
unique or primary key constraints on table "marketplaces"
"""
enum marketplaces_constraint {
  """
  unique or primary key constraint on columns "account"
  """
  marketplaces_account_key

  """
  unique or primary key constraint on columns "id"
  """
  marketplaces_pkey
}

"""
input type for incrementing numeric columns in table "marketplaces"
"""
input marketplaces_inc_input {
  account: Int
}

"""
input type for inserting data into table "marketplaces"
"""
input marketplaces_insert_input {
  account: Int
  accountByAccount: accounts_obj_rel_insert_input
  created_at: timestamp
  marketplace_name: String
  services: services_arr_rel_insert_input
}

"""aggregate max on columns"""
type marketplaces_max_fields {
  account: Int
  created_at: timestamp
  id: Int
  marketplace_name: String
}

"""aggregate min on columns"""
type marketplaces_min_fields {
  account: Int
  created_at: timestamp
  id: Int
  marketplace_name: String
}

"""
response of any mutation on the table "marketplaces"
"""
type marketplaces_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [marketplaces!]!
}

"""
input type for inserting object relation for remote table "marketplaces"
"""
input marketplaces_obj_rel_insert_input {
  data: marketplaces_insert_input!

  """upsert condition"""
  on_conflict: marketplaces_on_conflict
}

"""
on_conflict condition type for table "marketplaces"
"""
input marketplaces_on_conflict {
  constraint: marketplaces_constraint!
  update_columns: [marketplaces_update_column!]! = []
  where: marketplaces_bool_exp
}

"""Ordering options when selecting data from "marketplaces"."""
input marketplaces_order_by {
  account: order_by
  accountByAccount: accounts_order_by
  created_at: order_by
  id: order_by
  marketplace_name: order_by
  services_aggregate: services_aggregate_order_by
}

"""primary key columns input for table: marketplaces"""
input marketplaces_pk_columns_input {
  id: Int!
}

"""
select columns of table "marketplaces"
"""
enum marketplaces_select_column {
  """column name"""
  account

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  marketplace_name
}

"""
input type for updating data in table "marketplaces"
"""
input marketplaces_set_input {
  account: Int
  created_at: timestamp
  marketplace_name: String
}

"""aggregate stddev on columns"""
type marketplaces_stddev_fields {
  account: Float
  id: Float
}

"""aggregate stddev_pop on columns"""
type marketplaces_stddev_pop_fields {
  account: Float
  id: Float
}

"""aggregate stddev_samp on columns"""
type marketplaces_stddev_samp_fields {
  account: Float
  id: Float
}

"""
Streaming cursor of the table "marketplaces"
"""
input marketplaces_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: marketplaces_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input marketplaces_stream_cursor_value_input {
  account: Int
  created_at: timestamp
  id: Int
  marketplace_name: String
}

"""aggregate sum on columns"""
type marketplaces_sum_fields {
  account: Int
  id: Int
}

"""
update columns of table "marketplaces"
"""
enum marketplaces_update_column {
  """column name"""
  account

  """column name"""
  created_at

  """column name"""
  marketplace_name
}

input marketplaces_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: marketplaces_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: marketplaces_set_input

  """filter the rows which have to be updated"""
  where: marketplaces_bool_exp!
}

"""aggregate var_pop on columns"""
type marketplaces_var_pop_fields {
  account: Float
  id: Float
}

"""aggregate var_samp on columns"""
type marketplaces_var_samp_fields {
  account: Float
  id: Float
}

"""aggregate variance on columns"""
type marketplaces_variance_fields {
  account: Float
  id: Float
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "account_type"
  """
  delete_account_type(
    """filter the rows which have to be deleted"""
    where: account_type_bool_exp!
  ): account_type_mutation_response

  """
  delete single row from the table: "account_type"
  """
  delete_account_type_by_pk(value: String!): account_type

  """
  delete data from the table: "accounts"
  """
  delete_accounts(
    """filter the rows which have to be deleted"""
    where: accounts_bool_exp!
  ): accounts_mutation_response

  """
  delete single row from the table: "accounts"
  """
  delete_accounts_by_pk(id: Int!): accounts

  """
  delete data from the table: "gender_type"
  """
  delete_gender_type(
    """filter the rows which have to be deleted"""
    where: gender_type_bool_exp!
  ): gender_type_mutation_response

  """
  delete single row from the table: "gender_type"
  """
  delete_gender_type_by_pk(value: String!): gender_type

  """
  delete data from the table: "interface_type"
  """
  delete_interface_type(
    """filter the rows which have to be deleted"""
    where: interface_type_bool_exp!
  ): interface_type_mutation_response

  """
  delete single row from the table: "interface_type"
  """
  delete_interface_type_by_pk(value: String!): interface_type

  """
  delete data from the table: "marketplaces"
  """
  delete_marketplaces(
    """filter the rows which have to be deleted"""
    where: marketplaces_bool_exp!
  ): marketplaces_mutation_response

  """
  delete single row from the table: "marketplaces"
  """
  delete_marketplaces_by_pk(id: Int!): marketplaces

  """
  delete data from the table: "personal_information"
  """
  delete_personal_information(
    """filter the rows which have to be deleted"""
    where: personal_information_bool_exp!
  ): personal_information_mutation_response

  """
  delete data from the table: "service_accepted_payment"
  """
  delete_service_accepted_payment(
    """filter the rows which have to be deleted"""
    where: service_accepted_payment_bool_exp!
  ): service_accepted_payment_mutation_response

  """
  delete single row from the table: "service_accepted_payment"
  """
  delete_service_accepted_payment_by_pk(id: Int!): service_accepted_payment

  """
  delete data from the table: "service_type"
  """
  delete_service_type(
    """filter the rows which have to be deleted"""
    where: service_type_bool_exp!
  ): service_type_mutation_response

  """
  delete single row from the table: "service_type"
  """
  delete_service_type_by_pk(value: String!): service_type

  """
  delete data from the table: "services"
  """
  delete_services(
    """filter the rows which have to be deleted"""
    where: services_bool_exp!
  ): services_mutation_response

  """
  delete single row from the table: "services"
  """
  delete_services_by_pk(id: Int!): services

  """
  delete data from the table: "services_images"
  """
  delete_services_images(
    """filter the rows which have to be deleted"""
    where: services_images_bool_exp!
  ): services_images_mutation_response

  """
  delete single row from the table: "services_images"
  """
  delete_services_images_by_pk(id: Int!): services_images

  """
  delete data from the table: "services_ratings"
  """
  delete_services_ratings(
    """filter the rows which have to be deleted"""
    where: services_ratings_bool_exp!
  ): services_ratings_mutation_response

  """
  delete single row from the table: "services_ratings"
  """
  delete_services_ratings_by_pk(id: Int!): services_ratings

  """
  delete data from the table: "till"
  """
  delete_till(
    """filter the rows which have to be deleted"""
    where: till_bool_exp!
  ): till_mutation_response

  """
  delete single row from the table: "till"
  """
  delete_till_by_pk(id: Int!): till

  """
  delete data from the table: "transactions"
  """
  delete_transactions(
    """filter the rows which have to be deleted"""
    where: transactions_bool_exp!
  ): transactions_mutation_response

  """
  delete single row from the table: "transactions"
  """
  delete_transactions_by_pk(id: Int!): transactions

  """
  delete data from the table: "tx_type"
  """
  delete_tx_type(
    """filter the rows which have to be deleted"""
    where: tx_type_bool_exp!
  ): tx_type_mutation_response

  """
  delete single row from the table: "tx_type"
  """
  delete_tx_type_by_pk(value: String!): tx_type

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: Int!): users

  """
  delete data from the table: "voucher_backers"
  """
  delete_voucher_backers(
    """filter the rows which have to be deleted"""
    where: voucher_backers_bool_exp!
  ): voucher_backers_mutation_response

  """
  delete single row from the table: "voucher_backers"
  """
  delete_voucher_backers_by_pk(id: Int!): voucher_backers

  """
  delete data from the table: "voucher_certifications"
  """
  delete_voucher_certifications(
    """filter the rows which have to be deleted"""
    where: voucher_certifications_bool_exp!
  ): voucher_certifications_mutation_response

  """
  delete single row from the table: "voucher_certifications"
  """
  delete_voucher_certifications_by_pk(id: Int!): voucher_certifications

  """
  delete data from the table: "vouchers"
  """
  delete_vouchers(
    """filter the rows which have to be deleted"""
    where: vouchers_bool_exp!
  ): vouchers_mutation_response

  """
  delete single row from the table: "vouchers"
  """
  delete_vouchers_by_pk(id: Int!): vouchers

  """
  delete data from the table: "vpa"
  """
  delete_vpa(
    """filter the rows which have to be deleted"""
    where: vpa_bool_exp!
  ): vpa_mutation_response

  """
  delete single row from the table: "vpa"
  """
  delete_vpa_by_pk(id: Int!): vpa

  """
  insert data into the table: "account_type"
  """
  insert_account_type(
    """the rows to be inserted"""
    objects: [account_type_insert_input!]!

    """upsert condition"""
    on_conflict: account_type_on_conflict
  ): account_type_mutation_response

  """
  insert a single row into the table: "account_type"
  """
  insert_account_type_one(
    """the row to be inserted"""
    object: account_type_insert_input!

    """upsert condition"""
    on_conflict: account_type_on_conflict
  ): account_type

  """
  insert data into the table: "accounts"
  """
  insert_accounts(
    """the rows to be inserted"""
    objects: [accounts_insert_input!]!

    """upsert condition"""
    on_conflict: accounts_on_conflict
  ): accounts_mutation_response

  """
  insert a single row into the table: "accounts"
  """
  insert_accounts_one(
    """the row to be inserted"""
    object: accounts_insert_input!

    """upsert condition"""
    on_conflict: accounts_on_conflict
  ): accounts

  """
  insert data into the table: "gender_type"
  """
  insert_gender_type(
    """the rows to be inserted"""
    objects: [gender_type_insert_input!]!

    """upsert condition"""
    on_conflict: gender_type_on_conflict
  ): gender_type_mutation_response

  """
  insert a single row into the table: "gender_type"
  """
  insert_gender_type_one(
    """the row to be inserted"""
    object: gender_type_insert_input!

    """upsert condition"""
    on_conflict: gender_type_on_conflict
  ): gender_type

  """
  insert data into the table: "interface_type"
  """
  insert_interface_type(
    """the rows to be inserted"""
    objects: [interface_type_insert_input!]!

    """upsert condition"""
    on_conflict: interface_type_on_conflict
  ): interface_type_mutation_response

  """
  insert a single row into the table: "interface_type"
  """
  insert_interface_type_one(
    """the row to be inserted"""
    object: interface_type_insert_input!

    """upsert condition"""
    on_conflict: interface_type_on_conflict
  ): interface_type

  """
  insert data into the table: "marketplaces"
  """
  insert_marketplaces(
    """the rows to be inserted"""
    objects: [marketplaces_insert_input!]!

    """upsert condition"""
    on_conflict: marketplaces_on_conflict
  ): marketplaces_mutation_response

  """
  insert a single row into the table: "marketplaces"
  """
  insert_marketplaces_one(
    """the row to be inserted"""
    object: marketplaces_insert_input!

    """upsert condition"""
    on_conflict: marketplaces_on_conflict
  ): marketplaces

  """
  insert data into the table: "personal_information"
  """
  insert_personal_information(
    """the rows to be inserted"""
    objects: [personal_information_insert_input!]!

    """upsert condition"""
    on_conflict: personal_information_on_conflict
  ): personal_information_mutation_response

  """
  insert a single row into the table: "personal_information"
  """
  insert_personal_information_one(
    """the row to be inserted"""
    object: personal_information_insert_input!

    """upsert condition"""
    on_conflict: personal_information_on_conflict
  ): personal_information

  """
  insert data into the table: "service_accepted_payment"
  """
  insert_service_accepted_payment(
    """the rows to be inserted"""
    objects: [service_accepted_payment_insert_input!]!

    """upsert condition"""
    on_conflict: service_accepted_payment_on_conflict
  ): service_accepted_payment_mutation_response

  """
  insert a single row into the table: "service_accepted_payment"
  """
  insert_service_accepted_payment_one(
    """the row to be inserted"""
    object: service_accepted_payment_insert_input!

    """upsert condition"""
    on_conflict: service_accepted_payment_on_conflict
  ): service_accepted_payment

  """
  insert data into the table: "service_type"
  """
  insert_service_type(
    """the rows to be inserted"""
    objects: [service_type_insert_input!]!

    """upsert condition"""
    on_conflict: service_type_on_conflict
  ): service_type_mutation_response

  """
  insert a single row into the table: "service_type"
  """
  insert_service_type_one(
    """the row to be inserted"""
    object: service_type_insert_input!

    """upsert condition"""
    on_conflict: service_type_on_conflict
  ): service_type

  """
  insert data into the table: "services"
  """
  insert_services(
    """the rows to be inserted"""
    objects: [services_insert_input!]!

    """upsert condition"""
    on_conflict: services_on_conflict
  ): services_mutation_response

  """
  insert data into the table: "services_images"
  """
  insert_services_images(
    """the rows to be inserted"""
    objects: [services_images_insert_input!]!

    """upsert condition"""
    on_conflict: services_images_on_conflict
  ): services_images_mutation_response

  """
  insert a single row into the table: "services_images"
  """
  insert_services_images_one(
    """the row to be inserted"""
    object: services_images_insert_input!

    """upsert condition"""
    on_conflict: services_images_on_conflict
  ): services_images

  """
  insert a single row into the table: "services"
  """
  insert_services_one(
    """the row to be inserted"""
    object: services_insert_input!

    """upsert condition"""
    on_conflict: services_on_conflict
  ): services

  """
  insert data into the table: "services_ratings"
  """
  insert_services_ratings(
    """the rows to be inserted"""
    objects: [services_ratings_insert_input!]!

    """upsert condition"""
    on_conflict: services_ratings_on_conflict
  ): services_ratings_mutation_response

  """
  insert a single row into the table: "services_ratings"
  """
  insert_services_ratings_one(
    """the row to be inserted"""
    object: services_ratings_insert_input!

    """upsert condition"""
    on_conflict: services_ratings_on_conflict
  ): services_ratings

  """
  insert data into the table: "till"
  """
  insert_till(
    """the rows to be inserted"""
    objects: [till_insert_input!]!

    """upsert condition"""
    on_conflict: till_on_conflict
  ): till_mutation_response

  """
  insert a single row into the table: "till"
  """
  insert_till_one(
    """the row to be inserted"""
    object: till_insert_input!

    """upsert condition"""
    on_conflict: till_on_conflict
  ): till

  """
  insert data into the table: "transactions"
  """
  insert_transactions(
    """the rows to be inserted"""
    objects: [transactions_insert_input!]!

    """upsert condition"""
    on_conflict: transactions_on_conflict
  ): transactions_mutation_response

  """
  insert a single row into the table: "transactions"
  """
  insert_transactions_one(
    """the row to be inserted"""
    object: transactions_insert_input!

    """upsert condition"""
    on_conflict: transactions_on_conflict
  ): transactions

  """
  insert data into the table: "tx_type"
  """
  insert_tx_type(
    """the rows to be inserted"""
    objects: [tx_type_insert_input!]!

    """upsert condition"""
    on_conflict: tx_type_on_conflict
  ): tx_type_mutation_response

  """
  insert a single row into the table: "tx_type"
  """
  insert_tx_type_one(
    """the row to be inserted"""
    object: tx_type_insert_input!

    """upsert condition"""
    on_conflict: tx_type_on_conflict
  ): tx_type

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "voucher_backers"
  """
  insert_voucher_backers(
    """the rows to be inserted"""
    objects: [voucher_backers_insert_input!]!

    """upsert condition"""
    on_conflict: voucher_backers_on_conflict
  ): voucher_backers_mutation_response

  """
  insert a single row into the table: "voucher_backers"
  """
  insert_voucher_backers_one(
    """the row to be inserted"""
    object: voucher_backers_insert_input!

    """upsert condition"""
    on_conflict: voucher_backers_on_conflict
  ): voucher_backers

  """
  insert data into the table: "voucher_certifications"
  """
  insert_voucher_certifications(
    """the rows to be inserted"""
    objects: [voucher_certifications_insert_input!]!

    """upsert condition"""
    on_conflict: voucher_certifications_on_conflict
  ): voucher_certifications_mutation_response

  """
  insert a single row into the table: "voucher_certifications"
  """
  insert_voucher_certifications_one(
    """the row to be inserted"""
    object: voucher_certifications_insert_input!

    """upsert condition"""
    on_conflict: voucher_certifications_on_conflict
  ): voucher_certifications

  """
  insert data into the table: "vouchers"
  """
  insert_vouchers(
    """the rows to be inserted"""
    objects: [vouchers_insert_input!]!

    """upsert condition"""
    on_conflict: vouchers_on_conflict
  ): vouchers_mutation_response

  """
  insert a single row into the table: "vouchers"
  """
  insert_vouchers_one(
    """the row to be inserted"""
    object: vouchers_insert_input!

    """upsert condition"""
    on_conflict: vouchers_on_conflict
  ): vouchers

  """
  insert data into the table: "vpa"
  """
  insert_vpa(
    """the rows to be inserted"""
    objects: [vpa_insert_input!]!

    """upsert condition"""
    on_conflict: vpa_on_conflict
  ): vpa_mutation_response

  """
  insert a single row into the table: "vpa"
  """
  insert_vpa_one(
    """the row to be inserted"""
    object: vpa_insert_input!

    """upsert condition"""
    on_conflict: vpa_on_conflict
  ): vpa

  """
  update data of the table: "account_type"
  """
  update_account_type(
    """sets the columns of the filtered rows to the given values"""
    _set: account_type_set_input

    """filter the rows which have to be updated"""
    where: account_type_bool_exp!
  ): account_type_mutation_response

  """
  update single row of the table: "account_type"
  """
  update_account_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: account_type_set_input
    pk_columns: account_type_pk_columns_input!
  ): account_type

  """
  update multiples rows of table: "account_type"
  """
  update_account_type_many(
    """updates to execute, in order"""
    updates: [account_type_updates!]!
  ): [account_type_mutation_response]

  """
  update data of the table: "accounts"
  """
  update_accounts(
    """increments the numeric columns with given value of the filtered values"""
    _inc: accounts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_set_input

    """filter the rows which have to be updated"""
    where: accounts_bool_exp!
  ): accounts_mutation_response

  """
  update single row of the table: "accounts"
  """
  update_accounts_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: accounts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_set_input
    pk_columns: accounts_pk_columns_input!
  ): accounts

  """
  update multiples rows of table: "accounts"
  """
  update_accounts_many(
    """updates to execute, in order"""
    updates: [accounts_updates!]!
  ): [accounts_mutation_response]

  """
  update data of the table: "gender_type"
  """
  update_gender_type(
    """sets the columns of the filtered rows to the given values"""
    _set: gender_type_set_input

    """filter the rows which have to be updated"""
    where: gender_type_bool_exp!
  ): gender_type_mutation_response

  """
  update single row of the table: "gender_type"
  """
  update_gender_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: gender_type_set_input
    pk_columns: gender_type_pk_columns_input!
  ): gender_type

  """
  update multiples rows of table: "gender_type"
  """
  update_gender_type_many(
    """updates to execute, in order"""
    updates: [gender_type_updates!]!
  ): [gender_type_mutation_response]

  """
  update data of the table: "interface_type"
  """
  update_interface_type(
    """sets the columns of the filtered rows to the given values"""
    _set: interface_type_set_input

    """filter the rows which have to be updated"""
    where: interface_type_bool_exp!
  ): interface_type_mutation_response

  """
  update single row of the table: "interface_type"
  """
  update_interface_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: interface_type_set_input
    pk_columns: interface_type_pk_columns_input!
  ): interface_type

  """
  update multiples rows of table: "interface_type"
  """
  update_interface_type_many(
    """updates to execute, in order"""
    updates: [interface_type_updates!]!
  ): [interface_type_mutation_response]

  """
  update data of the table: "marketplaces"
  """
  update_marketplaces(
    """increments the numeric columns with given value of the filtered values"""
    _inc: marketplaces_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: marketplaces_set_input

    """filter the rows which have to be updated"""
    where: marketplaces_bool_exp!
  ): marketplaces_mutation_response

  """
  update single row of the table: "marketplaces"
  """
  update_marketplaces_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: marketplaces_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: marketplaces_set_input
    pk_columns: marketplaces_pk_columns_input!
  ): marketplaces

  """
  update multiples rows of table: "marketplaces"
  """
  update_marketplaces_many(
    """updates to execute, in order"""
    updates: [marketplaces_updates!]!
  ): [marketplaces_mutation_response]

  """
  update data of the table: "personal_information"
  """
  update_personal_information(
    """increments the numeric columns with given value of the filtered values"""
    _inc: personal_information_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: personal_information_set_input

    """filter the rows which have to be updated"""
    where: personal_information_bool_exp!
  ): personal_information_mutation_response

  """
  update multiples rows of table: "personal_information"
  """
  update_personal_information_many(
    """updates to execute, in order"""
    updates: [personal_information_updates!]!
  ): [personal_information_mutation_response]

  """
  update data of the table: "service_accepted_payment"
  """
  update_service_accepted_payment(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_accepted_payment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_accepted_payment_set_input

    """filter the rows which have to be updated"""
    where: service_accepted_payment_bool_exp!
  ): service_accepted_payment_mutation_response

  """
  update single row of the table: "service_accepted_payment"
  """
  update_service_accepted_payment_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: service_accepted_payment_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: service_accepted_payment_set_input
    pk_columns: service_accepted_payment_pk_columns_input!
  ): service_accepted_payment

  """
  update multiples rows of table: "service_accepted_payment"
  """
  update_service_accepted_payment_many(
    """updates to execute, in order"""
    updates: [service_accepted_payment_updates!]!
  ): [service_accepted_payment_mutation_response]

  """
  update data of the table: "service_type"
  """
  update_service_type(
    """sets the columns of the filtered rows to the given values"""
    _set: service_type_set_input

    """filter the rows which have to be updated"""
    where: service_type_bool_exp!
  ): service_type_mutation_response

  """
  update single row of the table: "service_type"
  """
  update_service_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: service_type_set_input
    pk_columns: service_type_pk_columns_input!
  ): service_type

  """
  update multiples rows of table: "service_type"
  """
  update_service_type_many(
    """updates to execute, in order"""
    updates: [service_type_updates!]!
  ): [service_type_mutation_response]

  """
  update data of the table: "services"
  """
  update_services(
    """increments the numeric columns with given value of the filtered values"""
    _inc: services_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: services_set_input

    """filter the rows which have to be updated"""
    where: services_bool_exp!
  ): services_mutation_response

  """
  update single row of the table: "services"
  """
  update_services_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: services_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: services_set_input
    pk_columns: services_pk_columns_input!
  ): services

  """
  update data of the table: "services_images"
  """
  update_services_images(
    """increments the numeric columns with given value of the filtered values"""
    _inc: services_images_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: services_images_set_input

    """filter the rows which have to be updated"""
    where: services_images_bool_exp!
  ): services_images_mutation_response

  """
  update single row of the table: "services_images"
  """
  update_services_images_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: services_images_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: services_images_set_input
    pk_columns: services_images_pk_columns_input!
  ): services_images

  """
  update multiples rows of table: "services_images"
  """
  update_services_images_many(
    """updates to execute, in order"""
    updates: [services_images_updates!]!
  ): [services_images_mutation_response]

  """
  update multiples rows of table: "services"
  """
  update_services_many(
    """updates to execute, in order"""
    updates: [services_updates!]!
  ): [services_mutation_response]

  """
  update data of the table: "services_ratings"
  """
  update_services_ratings(
    """increments the numeric columns with given value of the filtered values"""
    _inc: services_ratings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: services_ratings_set_input

    """filter the rows which have to be updated"""
    where: services_ratings_bool_exp!
  ): services_ratings_mutation_response

  """
  update single row of the table: "services_ratings"
  """
  update_services_ratings_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: services_ratings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: services_ratings_set_input
    pk_columns: services_ratings_pk_columns_input!
  ): services_ratings

  """
  update multiples rows of table: "services_ratings"
  """
  update_services_ratings_many(
    """updates to execute, in order"""
    updates: [services_ratings_updates!]!
  ): [services_ratings_mutation_response]

  """
  update data of the table: "till"
  """
  update_till(
    """increments the numeric columns with given value of the filtered values"""
    _inc: till_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: till_set_input

    """filter the rows which have to be updated"""
    where: till_bool_exp!
  ): till_mutation_response

  """
  update single row of the table: "till"
  """
  update_till_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: till_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: till_set_input
    pk_columns: till_pk_columns_input!
  ): till

  """
  update multiples rows of table: "till"
  """
  update_till_many(
    """updates to execute, in order"""
    updates: [till_updates!]!
  ): [till_mutation_response]

  """
  update data of the table: "transactions"
  """
  update_transactions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: transactions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: transactions_set_input

    """filter the rows which have to be updated"""
    where: transactions_bool_exp!
  ): transactions_mutation_response

  """
  update single row of the table: "transactions"
  """
  update_transactions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: transactions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: transactions_set_input
    pk_columns: transactions_pk_columns_input!
  ): transactions

  """
  update multiples rows of table: "transactions"
  """
  update_transactions_many(
    """updates to execute, in order"""
    updates: [transactions_updates!]!
  ): [transactions_mutation_response]

  """
  update data of the table: "tx_type"
  """
  update_tx_type(
    """sets the columns of the filtered rows to the given values"""
    _set: tx_type_set_input

    """filter the rows which have to be updated"""
    where: tx_type_bool_exp!
  ): tx_type_mutation_response

  """
  update single row of the table: "tx_type"
  """
  update_tx_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: tx_type_set_input
    pk_columns: tx_type_pk_columns_input!
  ): tx_type

  """
  update multiples rows of table: "tx_type"
  """
  update_tx_type_many(
    """updates to execute, in order"""
    updates: [tx_type_updates!]!
  ): [tx_type_mutation_response]

  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update multiples rows of table: "users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]

  """
  update data of the table: "voucher_backers"
  """
  update_voucher_backers(
    """increments the numeric columns with given value of the filtered values"""
    _inc: voucher_backers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: voucher_backers_set_input

    """filter the rows which have to be updated"""
    where: voucher_backers_bool_exp!
  ): voucher_backers_mutation_response

  """
  update single row of the table: "voucher_backers"
  """
  update_voucher_backers_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: voucher_backers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: voucher_backers_set_input
    pk_columns: voucher_backers_pk_columns_input!
  ): voucher_backers

  """
  update multiples rows of table: "voucher_backers"
  """
  update_voucher_backers_many(
    """updates to execute, in order"""
    updates: [voucher_backers_updates!]!
  ): [voucher_backers_mutation_response]

  """
  update data of the table: "voucher_certifications"
  """
  update_voucher_certifications(
    """increments the numeric columns with given value of the filtered values"""
    _inc: voucher_certifications_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: voucher_certifications_set_input

    """filter the rows which have to be updated"""
    where: voucher_certifications_bool_exp!
  ): voucher_certifications_mutation_response

  """
  update single row of the table: "voucher_certifications"
  """
  update_voucher_certifications_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: voucher_certifications_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: voucher_certifications_set_input
    pk_columns: voucher_certifications_pk_columns_input!
  ): voucher_certifications

  """
  update multiples rows of table: "voucher_certifications"
  """
  update_voucher_certifications_many(
    """updates to execute, in order"""
    updates: [voucher_certifications_updates!]!
  ): [voucher_certifications_mutation_response]

  """
  update data of the table: "vouchers"
  """
  update_vouchers(
    """increments the numeric columns with given value of the filtered values"""
    _inc: vouchers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: vouchers_set_input

    """filter the rows which have to be updated"""
    where: vouchers_bool_exp!
  ): vouchers_mutation_response

  """
  update single row of the table: "vouchers"
  """
  update_vouchers_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: vouchers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: vouchers_set_input
    pk_columns: vouchers_pk_columns_input!
  ): vouchers

  """
  update multiples rows of table: "vouchers"
  """
  update_vouchers_many(
    """updates to execute, in order"""
    updates: [vouchers_updates!]!
  ): [vouchers_mutation_response]

  """
  update data of the table: "vpa"
  """
  update_vpa(
    """increments the numeric columns with given value of the filtered values"""
    _inc: vpa_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: vpa_set_input

    """filter the rows which have to be updated"""
    where: vpa_bool_exp!
  ): vpa_mutation_response

  """
  update single row of the table: "vpa"
  """
  update_vpa_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: vpa_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: vpa_set_input
    pk_columns: vpa_pk_columns_input!
  ): vpa

  """
  update multiples rows of table: "vpa"
  """
  update_vpa_many(
    """updates to execute, in order"""
    updates: [vpa_updates!]!
  ): [vpa_mutation_response]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "personal_information"
"""
type personal_information {
  family_name: String
  gender: gender_type_enum

  """An object relationship"""
  gender_type: gender_type
  geo: point
  given_names: String
  location_name: String

  """An object relationship"""
  user: users!
  user_identifier: Int!
  year_of_birth: Int
}

"""
aggregated selection of "personal_information"
"""
type personal_information_aggregate {
  aggregate: personal_information_aggregate_fields
  nodes: [personal_information!]!
}

input personal_information_aggregate_bool_exp {
  count: personal_information_aggregate_bool_exp_count
}

input personal_information_aggregate_bool_exp_count {
  arguments: [personal_information_select_column!]
  distinct: Boolean
  filter: personal_information_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "personal_information"
"""
type personal_information_aggregate_fields {
  avg: personal_information_avg_fields
  count(columns: [personal_information_select_column!], distinct: Boolean): Int!
  max: personal_information_max_fields
  min: personal_information_min_fields
  stddev: personal_information_stddev_fields
  stddev_pop: personal_information_stddev_pop_fields
  stddev_samp: personal_information_stddev_samp_fields
  sum: personal_information_sum_fields
  var_pop: personal_information_var_pop_fields
  var_samp: personal_information_var_samp_fields
  variance: personal_information_variance_fields
}

"""
order by aggregate values of table "personal_information"
"""
input personal_information_aggregate_order_by {
  avg: personal_information_avg_order_by
  count: order_by
  max: personal_information_max_order_by
  min: personal_information_min_order_by
  stddev: personal_information_stddev_order_by
  stddev_pop: personal_information_stddev_pop_order_by
  stddev_samp: personal_information_stddev_samp_order_by
  sum: personal_information_sum_order_by
  var_pop: personal_information_var_pop_order_by
  var_samp: personal_information_var_samp_order_by
  variance: personal_information_variance_order_by
}

"""
input type for inserting array relation for remote table "personal_information"
"""
input personal_information_arr_rel_insert_input {
  data: [personal_information_insert_input!]!

  """upsert condition"""
  on_conflict: personal_information_on_conflict
}

"""aggregate avg on columns"""
type personal_information_avg_fields {
  user_identifier: Float
  year_of_birth: Float
}

"""
order by avg() on columns of table "personal_information"
"""
input personal_information_avg_order_by {
  user_identifier: order_by
  year_of_birth: order_by
}

"""
Boolean expression to filter rows from the table "personal_information". All fields are combined with a logical 'AND'.
"""
input personal_information_bool_exp {
  _and: [personal_information_bool_exp!]
  _not: personal_information_bool_exp
  _or: [personal_information_bool_exp!]
  family_name: String_comparison_exp
  gender: gender_type_enum_comparison_exp
  gender_type: gender_type_bool_exp
  geo: point_comparison_exp
  given_names: String_comparison_exp
  location_name: String_comparison_exp
  user: users_bool_exp
  user_identifier: Int_comparison_exp
  year_of_birth: Int_comparison_exp
}

"""
unique or primary key constraints on table "personal_information"
"""
enum personal_information_constraint {
  """
  unique or primary key constraint on columns "user_identifier"
  """
  personal_information_user_identifier_key
}

"""
input type for incrementing numeric columns in table "personal_information"
"""
input personal_information_inc_input {
  user_identifier: Int
  year_of_birth: Int
}

"""
input type for inserting data into table "personal_information"
"""
input personal_information_insert_input {
  family_name: String
  gender: gender_type_enum
  gender_type: gender_type_obj_rel_insert_input
  geo: point
  given_names: String
  location_name: String
  user: users_obj_rel_insert_input
  user_identifier: Int
  year_of_birth: Int
}

"""aggregate max on columns"""
type personal_information_max_fields {
  family_name: String
  given_names: String
  location_name: String
  user_identifier: Int
  year_of_birth: Int
}

"""
order by max() on columns of table "personal_information"
"""
input personal_information_max_order_by {
  family_name: order_by
  given_names: order_by
  location_name: order_by
  user_identifier: order_by
  year_of_birth: order_by
}

"""aggregate min on columns"""
type personal_information_min_fields {
  family_name: String
  given_names: String
  location_name: String
  user_identifier: Int
  year_of_birth: Int
}

"""
order by min() on columns of table "personal_information"
"""
input personal_information_min_order_by {
  family_name: order_by
  given_names: order_by
  location_name: order_by
  user_identifier: order_by
  year_of_birth: order_by
}

"""
response of any mutation on the table "personal_information"
"""
type personal_information_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [personal_information!]!
}

"""
input type for inserting object relation for remote table "personal_information"
"""
input personal_information_obj_rel_insert_input {
  data: personal_information_insert_input!

  """upsert condition"""
  on_conflict: personal_information_on_conflict
}

"""
on_conflict condition type for table "personal_information"
"""
input personal_information_on_conflict {
  constraint: personal_information_constraint!
  update_columns: [personal_information_update_column!]! = []
  where: personal_information_bool_exp
}

"""Ordering options when selecting data from "personal_information"."""
input personal_information_order_by {
  family_name: order_by
  gender: order_by
  gender_type: gender_type_order_by
  geo: order_by
  given_names: order_by
  location_name: order_by
  user: users_order_by
  user_identifier: order_by
  year_of_birth: order_by
}

"""
select columns of table "personal_information"
"""
enum personal_information_select_column {
  """column name"""
  family_name

  """column name"""
  gender

  """column name"""
  geo

  """column name"""
  given_names

  """column name"""
  location_name

  """column name"""
  user_identifier

  """column name"""
  year_of_birth
}

"""
input type for updating data in table "personal_information"
"""
input personal_information_set_input {
  family_name: String
  gender: gender_type_enum
  geo: point
  given_names: String
  location_name: String
  user_identifier: Int
  year_of_birth: Int
}

"""aggregate stddev on columns"""
type personal_information_stddev_fields {
  user_identifier: Float
  year_of_birth: Float
}

"""
order by stddev() on columns of table "personal_information"
"""
input personal_information_stddev_order_by {
  user_identifier: order_by
  year_of_birth: order_by
}

"""aggregate stddev_pop on columns"""
type personal_information_stddev_pop_fields {
  user_identifier: Float
  year_of_birth: Float
}

"""
order by stddev_pop() on columns of table "personal_information"
"""
input personal_information_stddev_pop_order_by {
  user_identifier: order_by
  year_of_birth: order_by
}

"""aggregate stddev_samp on columns"""
type personal_information_stddev_samp_fields {
  user_identifier: Float
  year_of_birth: Float
}

"""
order by stddev_samp() on columns of table "personal_information"
"""
input personal_information_stddev_samp_order_by {
  user_identifier: order_by
  year_of_birth: order_by
}

"""
Streaming cursor of the table "personal_information"
"""
input personal_information_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: personal_information_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input personal_information_stream_cursor_value_input {
  family_name: String
  gender: gender_type_enum
  geo: point
  given_names: String
  location_name: String
  user_identifier: Int
  year_of_birth: Int
}

"""aggregate sum on columns"""
type personal_information_sum_fields {
  user_identifier: Int
  year_of_birth: Int
}

"""
order by sum() on columns of table "personal_information"
"""
input personal_information_sum_order_by {
  user_identifier: order_by
  year_of_birth: order_by
}

"""
update columns of table "personal_information"
"""
enum personal_information_update_column {
  """column name"""
  family_name

  """column name"""
  gender

  """column name"""
  geo

  """column name"""
  given_names

  """column name"""
  location_name

  """column name"""
  user_identifier

  """column name"""
  year_of_birth
}

input personal_information_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: personal_information_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: personal_information_set_input

  """filter the rows which have to be updated"""
  where: personal_information_bool_exp!
}

"""aggregate var_pop on columns"""
type personal_information_var_pop_fields {
  user_identifier: Float
  year_of_birth: Float
}

"""
order by var_pop() on columns of table "personal_information"
"""
input personal_information_var_pop_order_by {
  user_identifier: order_by
  year_of_birth: order_by
}

"""aggregate var_samp on columns"""
type personal_information_var_samp_fields {
  user_identifier: Float
  year_of_birth: Float
}

"""
order by var_samp() on columns of table "personal_information"
"""
input personal_information_var_samp_order_by {
  user_identifier: order_by
  year_of_birth: order_by
}

"""aggregate variance on columns"""
type personal_information_variance_fields {
  user_identifier: Float
  year_of_birth: Float
}

"""
order by variance() on columns of table "personal_information"
"""
input personal_information_variance_order_by {
  user_identifier: order_by
  year_of_birth: order_by
}

scalar point

"""
Boolean expression to compare columns of type "point". All fields are combined with logical 'AND'.
"""
input point_comparison_exp {
  _eq: point
  _gt: point
  _gte: point
  _in: [point!]
  _is_null: Boolean
  _lt: point
  _lte: point
  _neq: point
  _nin: [point!]
}

type query_root {
  """
  fetch data from the table: "account_type"
  """
  account_type(
    """distinct select on columns"""
    distinct_on: [account_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_type_order_by!]

    """filter the rows returned"""
    where: account_type_bool_exp
  ): [account_type!]!

  """
  fetch aggregated fields from the table: "account_type"
  """
  account_type_aggregate(
    """distinct select on columns"""
    distinct_on: [account_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_type_order_by!]

    """filter the rows returned"""
    where: account_type_bool_exp
  ): account_type_aggregate!

  """fetch data from the table: "account_type" using primary key columns"""
  account_type_by_pk(value: String!): account_type

  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): accounts_aggregate!

  """fetch data from the table: "accounts" using primary key columns"""
  accounts_by_pk(id: Int!): accounts

  """
  fetch data from the table: "gender_type"
  """
  gender_type(
    """distinct select on columns"""
    distinct_on: [gender_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_type_order_by!]

    """filter the rows returned"""
    where: gender_type_bool_exp
  ): [gender_type!]!

  """
  fetch aggregated fields from the table: "gender_type"
  """
  gender_type_aggregate(
    """distinct select on columns"""
    distinct_on: [gender_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_type_order_by!]

    """filter the rows returned"""
    where: gender_type_bool_exp
  ): gender_type_aggregate!

  """fetch data from the table: "gender_type" using primary key columns"""
  gender_type_by_pk(value: String!): gender_type

  """
  fetch data from the table: "interface_type"
  """
  interface_type(
    """distinct select on columns"""
    distinct_on: [interface_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interface_type_order_by!]

    """filter the rows returned"""
    where: interface_type_bool_exp
  ): [interface_type!]!

  """
  fetch aggregated fields from the table: "interface_type"
  """
  interface_type_aggregate(
    """distinct select on columns"""
    distinct_on: [interface_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interface_type_order_by!]

    """filter the rows returned"""
    where: interface_type_bool_exp
  ): interface_type_aggregate!

  """fetch data from the table: "interface_type" using primary key columns"""
  interface_type_by_pk(value: String!): interface_type

  """
  fetch data from the table: "marketplaces"
  """
  marketplaces(
    """distinct select on columns"""
    distinct_on: [marketplaces_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [marketplaces_order_by!]

    """filter the rows returned"""
    where: marketplaces_bool_exp
  ): [marketplaces!]!

  """
  fetch aggregated fields from the table: "marketplaces"
  """
  marketplaces_aggregate(
    """distinct select on columns"""
    distinct_on: [marketplaces_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [marketplaces_order_by!]

    """filter the rows returned"""
    where: marketplaces_bool_exp
  ): marketplaces_aggregate!

  """fetch data from the table: "marketplaces" using primary key columns"""
  marketplaces_by_pk(id: Int!): marketplaces

  """
  fetch data from the table: "personal_information"
  """
  personal_information(
    """distinct select on columns"""
    distinct_on: [personal_information_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [personal_information_order_by!]

    """filter the rows returned"""
    where: personal_information_bool_exp
  ): [personal_information!]!

  """
  fetch aggregated fields from the table: "personal_information"
  """
  personal_information_aggregate(
    """distinct select on columns"""
    distinct_on: [personal_information_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [personal_information_order_by!]

    """filter the rows returned"""
    where: personal_information_bool_exp
  ): personal_information_aggregate!

  """
  fetch data from the table: "service_accepted_payment"
  """
  service_accepted_payment(
    """distinct select on columns"""
    distinct_on: [service_accepted_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_accepted_payment_order_by!]

    """filter the rows returned"""
    where: service_accepted_payment_bool_exp
  ): [service_accepted_payment!]!

  """
  fetch aggregated fields from the table: "service_accepted_payment"
  """
  service_accepted_payment_aggregate(
    """distinct select on columns"""
    distinct_on: [service_accepted_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_accepted_payment_order_by!]

    """filter the rows returned"""
    where: service_accepted_payment_bool_exp
  ): service_accepted_payment_aggregate!

  """
  fetch data from the table: "service_accepted_payment" using primary key columns
  """
  service_accepted_payment_by_pk(id: Int!): service_accepted_payment

  """
  fetch data from the table: "service_type"
  """
  service_type(
    """distinct select on columns"""
    distinct_on: [service_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_type_order_by!]

    """filter the rows returned"""
    where: service_type_bool_exp
  ): [service_type!]!

  """
  fetch aggregated fields from the table: "service_type"
  """
  service_type_aggregate(
    """distinct select on columns"""
    distinct_on: [service_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_type_order_by!]

    """filter the rows returned"""
    where: service_type_bool_exp
  ): service_type_aggregate!

  """fetch data from the table: "service_type" using primary key columns"""
  service_type_by_pk(value: String!): service_type

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """fetch data from the table: "services" using primary key columns"""
  services_by_pk(id: Int!): services

  """An array relationship"""
  services_images(
    """distinct select on columns"""
    distinct_on: [services_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_images_order_by!]

    """filter the rows returned"""
    where: services_images_bool_exp
  ): [services_images!]!

  """An aggregate relationship"""
  services_images_aggregate(
    """distinct select on columns"""
    distinct_on: [services_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_images_order_by!]

    """filter the rows returned"""
    where: services_images_bool_exp
  ): services_images_aggregate!

  """fetch data from the table: "services_images" using primary key columns"""
  services_images_by_pk(id: Int!): services_images

  """An array relationship"""
  services_ratings(
    """distinct select on columns"""
    distinct_on: [services_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_ratings_order_by!]

    """filter the rows returned"""
    where: services_ratings_bool_exp
  ): [services_ratings!]!

  """An aggregate relationship"""
  services_ratings_aggregate(
    """distinct select on columns"""
    distinct_on: [services_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_ratings_order_by!]

    """filter the rows returned"""
    where: services_ratings_bool_exp
  ): services_ratings_aggregate!

  """
  fetch data from the table: "services_ratings" using primary key columns
  """
  services_ratings_by_pk(id: Int!): services_ratings

  """
  fetch data from the table: "till"
  """
  till(
    """distinct select on columns"""
    distinct_on: [till_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [till_order_by!]

    """filter the rows returned"""
    where: till_bool_exp
  ): [till!]!

  """
  fetch aggregated fields from the table: "till"
  """
  till_aggregate(
    """distinct select on columns"""
    distinct_on: [till_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [till_order_by!]

    """filter the rows returned"""
    where: till_bool_exp
  ): till_aggregate!

  """fetch data from the table: "till" using primary key columns"""
  till_by_pk(id: Int!): till

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): [transactions!]!

  """An aggregate relationship"""
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): transactions_aggregate!

  """fetch data from the table: "transactions" using primary key columns"""
  transactions_by_pk(id: Int!): transactions

  """
  fetch data from the table: "tx_type"
  """
  tx_type(
    """distinct select on columns"""
    distinct_on: [tx_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tx_type_order_by!]

    """filter the rows returned"""
    where: tx_type_bool_exp
  ): [tx_type!]!

  """
  fetch aggregated fields from the table: "tx_type"
  """
  tx_type_aggregate(
    """distinct select on columns"""
    distinct_on: [tx_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tx_type_order_by!]

    """filter the rows returned"""
    where: tx_type_bool_exp
  ): tx_type_aggregate!

  """fetch data from the table: "tx_type" using primary key columns"""
  tx_type_by_pk(value: String!): tx_type

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: Int!): users

  """An array relationship"""
  voucher_backers(
    """distinct select on columns"""
    distinct_on: [voucher_backers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_backers_order_by!]

    """filter the rows returned"""
    where: voucher_backers_bool_exp
  ): [voucher_backers!]!

  """An aggregate relationship"""
  voucher_backers_aggregate(
    """distinct select on columns"""
    distinct_on: [voucher_backers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_backers_order_by!]

    """filter the rows returned"""
    where: voucher_backers_bool_exp
  ): voucher_backers_aggregate!

  """fetch data from the table: "voucher_backers" using primary key columns"""
  voucher_backers_by_pk(id: Int!): voucher_backers

  """An array relationship"""
  voucher_certifications(
    """distinct select on columns"""
    distinct_on: [voucher_certifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_certifications_order_by!]

    """filter the rows returned"""
    where: voucher_certifications_bool_exp
  ): [voucher_certifications!]!

  """An aggregate relationship"""
  voucher_certifications_aggregate(
    """distinct select on columns"""
    distinct_on: [voucher_certifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_certifications_order_by!]

    """filter the rows returned"""
    where: voucher_certifications_bool_exp
  ): voucher_certifications_aggregate!

  """
  fetch data from the table: "voucher_certifications" using primary key columns
  """
  voucher_certifications_by_pk(id: Int!): voucher_certifications

  """
  fetch data from the table: "vouchers"
  """
  vouchers(
    """distinct select on columns"""
    distinct_on: [vouchers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vouchers_order_by!]

    """filter the rows returned"""
    where: vouchers_bool_exp
  ): [vouchers!]!

  """
  fetch aggregated fields from the table: "vouchers"
  """
  vouchers_aggregate(
    """distinct select on columns"""
    distinct_on: [vouchers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vouchers_order_by!]

    """filter the rows returned"""
    where: vouchers_bool_exp
  ): vouchers_aggregate!

  """fetch data from the table: "vouchers" using primary key columns"""
  vouchers_by_pk(id: Int!): vouchers

  """
  fetch data from the table: "vpa"
  """
  vpa(
    """distinct select on columns"""
    distinct_on: [vpa_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vpa_order_by!]

    """filter the rows returned"""
    where: vpa_bool_exp
  ): [vpa!]!

  """
  fetch aggregated fields from the table: "vpa"
  """
  vpa_aggregate(
    """distinct select on columns"""
    distinct_on: [vpa_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vpa_order_by!]

    """filter the rows returned"""
    where: vpa_bool_exp
  ): vpa_aggregate!

  """fetch data from the table: "vpa" using primary key columns"""
  vpa_by_pk(id: Int!): vpa
}

"""
columns and relationships of "service_accepted_payment"
"""
type service_accepted_payment {
  id: Int!
  price: float8!

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!
  voucher: Int!

  """An object relationship"""
  voucherByVoucher: vouchers!
}

"""
aggregated selection of "service_accepted_payment"
"""
type service_accepted_payment_aggregate {
  aggregate: service_accepted_payment_aggregate_fields
  nodes: [service_accepted_payment!]!
}

input service_accepted_payment_aggregate_bool_exp {
  avg: service_accepted_payment_aggregate_bool_exp_avg
  corr: service_accepted_payment_aggregate_bool_exp_corr
  count: service_accepted_payment_aggregate_bool_exp_count
  covar_samp: service_accepted_payment_aggregate_bool_exp_covar_samp
  max: service_accepted_payment_aggregate_bool_exp_max
  min: service_accepted_payment_aggregate_bool_exp_min
  stddev_samp: service_accepted_payment_aggregate_bool_exp_stddev_samp
  sum: service_accepted_payment_aggregate_bool_exp_sum
  var_samp: service_accepted_payment_aggregate_bool_exp_var_samp
}

input service_accepted_payment_aggregate_bool_exp_avg {
  arguments: service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_avg_arguments_columns!
  distinct: Boolean
  filter: service_accepted_payment_bool_exp
  predicate: float8_comparison_exp!
}

input service_accepted_payment_aggregate_bool_exp_corr {
  arguments: service_accepted_payment_aggregate_bool_exp_corr_arguments!
  distinct: Boolean
  filter: service_accepted_payment_bool_exp
  predicate: float8_comparison_exp!
}

input service_accepted_payment_aggregate_bool_exp_corr_arguments {
  X: service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_corr_arguments_columns!
  Y: service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_corr_arguments_columns!
}

input service_accepted_payment_aggregate_bool_exp_count {
  arguments: [service_accepted_payment_select_column!]
  distinct: Boolean
  filter: service_accepted_payment_bool_exp
  predicate: Int_comparison_exp!
}

input service_accepted_payment_aggregate_bool_exp_covar_samp {
  arguments: service_accepted_payment_aggregate_bool_exp_covar_samp_arguments!
  distinct: Boolean
  filter: service_accepted_payment_bool_exp
  predicate: float8_comparison_exp!
}

input service_accepted_payment_aggregate_bool_exp_covar_samp_arguments {
  X: service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_covar_samp_arguments_columns!
  Y: service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_covar_samp_arguments_columns!
}

input service_accepted_payment_aggregate_bool_exp_max {
  arguments: service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_max_arguments_columns!
  distinct: Boolean
  filter: service_accepted_payment_bool_exp
  predicate: float8_comparison_exp!
}

input service_accepted_payment_aggregate_bool_exp_min {
  arguments: service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_min_arguments_columns!
  distinct: Boolean
  filter: service_accepted_payment_bool_exp
  predicate: float8_comparison_exp!
}

input service_accepted_payment_aggregate_bool_exp_stddev_samp {
  arguments: service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_stddev_samp_arguments_columns!
  distinct: Boolean
  filter: service_accepted_payment_bool_exp
  predicate: float8_comparison_exp!
}

input service_accepted_payment_aggregate_bool_exp_sum {
  arguments: service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_sum_arguments_columns!
  distinct: Boolean
  filter: service_accepted_payment_bool_exp
  predicate: float8_comparison_exp!
}

input service_accepted_payment_aggregate_bool_exp_var_samp {
  arguments: service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_var_samp_arguments_columns!
  distinct: Boolean
  filter: service_accepted_payment_bool_exp
  predicate: float8_comparison_exp!
}

"""
aggregate fields of "service_accepted_payment"
"""
type service_accepted_payment_aggregate_fields {
  avg: service_accepted_payment_avg_fields
  count(columns: [service_accepted_payment_select_column!], distinct: Boolean): Int!
  max: service_accepted_payment_max_fields
  min: service_accepted_payment_min_fields
  stddev: service_accepted_payment_stddev_fields
  stddev_pop: service_accepted_payment_stddev_pop_fields
  stddev_samp: service_accepted_payment_stddev_samp_fields
  sum: service_accepted_payment_sum_fields
  var_pop: service_accepted_payment_var_pop_fields
  var_samp: service_accepted_payment_var_samp_fields
  variance: service_accepted_payment_variance_fields
}

"""
order by aggregate values of table "service_accepted_payment"
"""
input service_accepted_payment_aggregate_order_by {
  avg: service_accepted_payment_avg_order_by
  count: order_by
  max: service_accepted_payment_max_order_by
  min: service_accepted_payment_min_order_by
  stddev: service_accepted_payment_stddev_order_by
  stddev_pop: service_accepted_payment_stddev_pop_order_by
  stddev_samp: service_accepted_payment_stddev_samp_order_by
  sum: service_accepted_payment_sum_order_by
  var_pop: service_accepted_payment_var_pop_order_by
  var_samp: service_accepted_payment_var_samp_order_by
  variance: service_accepted_payment_variance_order_by
}

"""
input type for inserting array relation for remote table "service_accepted_payment"
"""
input service_accepted_payment_arr_rel_insert_input {
  data: [service_accepted_payment_insert_input!]!

  """upsert condition"""
  on_conflict: service_accepted_payment_on_conflict
}

"""aggregate avg on columns"""
type service_accepted_payment_avg_fields {
  id: Float
  price: Float
  voucher: Float
}

"""
order by avg() on columns of table "service_accepted_payment"
"""
input service_accepted_payment_avg_order_by {
  id: order_by
  price: order_by
  voucher: order_by
}

"""
Boolean expression to filter rows from the table "service_accepted_payment". All fields are combined with a logical 'AND'.
"""
input service_accepted_payment_bool_exp {
  _and: [service_accepted_payment_bool_exp!]
  _not: service_accepted_payment_bool_exp
  _or: [service_accepted_payment_bool_exp!]
  id: Int_comparison_exp
  price: float8_comparison_exp
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
  voucher: Int_comparison_exp
  voucherByVoucher: vouchers_bool_exp
}

"""
unique or primary key constraints on table "service_accepted_payment"
"""
enum service_accepted_payment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  service_accepted_payment_pkey
}

"""
input type for incrementing numeric columns in table "service_accepted_payment"
"""
input service_accepted_payment_inc_input {
  price: float8
  voucher: Int
}

"""
input type for inserting data into table "service_accepted_payment"
"""
input service_accepted_payment_insert_input {
  price: float8
  services: services_arr_rel_insert_input
  voucher: Int
  voucherByVoucher: vouchers_obj_rel_insert_input
}

"""aggregate max on columns"""
type service_accepted_payment_max_fields {
  id: Int
  price: float8
  voucher: Int
}

"""
order by max() on columns of table "service_accepted_payment"
"""
input service_accepted_payment_max_order_by {
  id: order_by
  price: order_by
  voucher: order_by
}

"""aggregate min on columns"""
type service_accepted_payment_min_fields {
  id: Int
  price: float8
  voucher: Int
}

"""
order by min() on columns of table "service_accepted_payment"
"""
input service_accepted_payment_min_order_by {
  id: order_by
  price: order_by
  voucher: order_by
}

"""
response of any mutation on the table "service_accepted_payment"
"""
type service_accepted_payment_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_accepted_payment!]!
}

"""
input type for inserting object relation for remote table "service_accepted_payment"
"""
input service_accepted_payment_obj_rel_insert_input {
  data: service_accepted_payment_insert_input!

  """upsert condition"""
  on_conflict: service_accepted_payment_on_conflict
}

"""
on_conflict condition type for table "service_accepted_payment"
"""
input service_accepted_payment_on_conflict {
  constraint: service_accepted_payment_constraint!
  update_columns: [service_accepted_payment_update_column!]! = []
  where: service_accepted_payment_bool_exp
}

"""Ordering options when selecting data from "service_accepted_payment"."""
input service_accepted_payment_order_by {
  id: order_by
  price: order_by
  services_aggregate: services_aggregate_order_by
  voucher: order_by
  voucherByVoucher: vouchers_order_by
}

"""primary key columns input for table: service_accepted_payment"""
input service_accepted_payment_pk_columns_input {
  id: Int!
}

"""
select columns of table "service_accepted_payment"
"""
enum service_accepted_payment_select_column {
  """column name"""
  id

  """column name"""
  price

  """column name"""
  voucher
}

"""
select "service_accepted_payment_aggregate_bool_exp_avg_arguments_columns" columns of table "service_accepted_payment"
"""
enum service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_avg_arguments_columns {
  """column name"""
  price
}

"""
select "service_accepted_payment_aggregate_bool_exp_corr_arguments_columns" columns of table "service_accepted_payment"
"""
enum service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_corr_arguments_columns {
  """column name"""
  price
}

"""
select "service_accepted_payment_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "service_accepted_payment"
"""
enum service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_covar_samp_arguments_columns {
  """column name"""
  price
}

"""
select "service_accepted_payment_aggregate_bool_exp_max_arguments_columns" columns of table "service_accepted_payment"
"""
enum service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_max_arguments_columns {
  """column name"""
  price
}

"""
select "service_accepted_payment_aggregate_bool_exp_min_arguments_columns" columns of table "service_accepted_payment"
"""
enum service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_min_arguments_columns {
  """column name"""
  price
}

"""
select "service_accepted_payment_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "service_accepted_payment"
"""
enum service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_stddev_samp_arguments_columns {
  """column name"""
  price
}

"""
select "service_accepted_payment_aggregate_bool_exp_sum_arguments_columns" columns of table "service_accepted_payment"
"""
enum service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_sum_arguments_columns {
  """column name"""
  price
}

"""
select "service_accepted_payment_aggregate_bool_exp_var_samp_arguments_columns" columns of table "service_accepted_payment"
"""
enum service_accepted_payment_select_column_service_accepted_payment_aggregate_bool_exp_var_samp_arguments_columns {
  """column name"""
  price
}

"""
input type for updating data in table "service_accepted_payment"
"""
input service_accepted_payment_set_input {
  price: float8
  voucher: Int
}

"""aggregate stddev on columns"""
type service_accepted_payment_stddev_fields {
  id: Float
  price: Float
  voucher: Float
}

"""
order by stddev() on columns of table "service_accepted_payment"
"""
input service_accepted_payment_stddev_order_by {
  id: order_by
  price: order_by
  voucher: order_by
}

"""aggregate stddev_pop on columns"""
type service_accepted_payment_stddev_pop_fields {
  id: Float
  price: Float
  voucher: Float
}

"""
order by stddev_pop() on columns of table "service_accepted_payment"
"""
input service_accepted_payment_stddev_pop_order_by {
  id: order_by
  price: order_by
  voucher: order_by
}

"""aggregate stddev_samp on columns"""
type service_accepted_payment_stddev_samp_fields {
  id: Float
  price: Float
  voucher: Float
}

"""
order by stddev_samp() on columns of table "service_accepted_payment"
"""
input service_accepted_payment_stddev_samp_order_by {
  id: order_by
  price: order_by
  voucher: order_by
}

"""
Streaming cursor of the table "service_accepted_payment"
"""
input service_accepted_payment_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_accepted_payment_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_accepted_payment_stream_cursor_value_input {
  id: Int
  price: float8
  voucher: Int
}

"""aggregate sum on columns"""
type service_accepted_payment_sum_fields {
  id: Int
  price: float8
  voucher: Int
}

"""
order by sum() on columns of table "service_accepted_payment"
"""
input service_accepted_payment_sum_order_by {
  id: order_by
  price: order_by
  voucher: order_by
}

"""
update columns of table "service_accepted_payment"
"""
enum service_accepted_payment_update_column {
  """column name"""
  price

  """column name"""
  voucher
}

input service_accepted_payment_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: service_accepted_payment_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: service_accepted_payment_set_input

  """filter the rows which have to be updated"""
  where: service_accepted_payment_bool_exp!
}

"""aggregate var_pop on columns"""
type service_accepted_payment_var_pop_fields {
  id: Float
  price: Float
  voucher: Float
}

"""
order by var_pop() on columns of table "service_accepted_payment"
"""
input service_accepted_payment_var_pop_order_by {
  id: order_by
  price: order_by
  voucher: order_by
}

"""aggregate var_samp on columns"""
type service_accepted_payment_var_samp_fields {
  id: Float
  price: Float
  voucher: Float
}

"""
order by var_samp() on columns of table "service_accepted_payment"
"""
input service_accepted_payment_var_samp_order_by {
  id: order_by
  price: order_by
  voucher: order_by
}

"""aggregate variance on columns"""
type service_accepted_payment_variance_fields {
  id: Float
  price: Float
  voucher: Float
}

"""
order by variance() on columns of table "service_accepted_payment"
"""
input service_accepted_payment_variance_order_by {
  id: order_by
  price: order_by
  voucher: order_by
}

"""
columns and relationships of "service_type"
"""
type service_type {
  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!
  value: String!
}

"""
aggregated selection of "service_type"
"""
type service_type_aggregate {
  aggregate: service_type_aggregate_fields
  nodes: [service_type!]!
}

"""
aggregate fields of "service_type"
"""
type service_type_aggregate_fields {
  count(columns: [service_type_select_column!], distinct: Boolean): Int!
  max: service_type_max_fields
  min: service_type_min_fields
}

"""
Boolean expression to filter rows from the table "service_type". All fields are combined with a logical 'AND'.
"""
input service_type_bool_exp {
  _and: [service_type_bool_exp!]
  _not: service_type_bool_exp
  _or: [service_type_bool_exp!]
  services: services_bool_exp
  services_aggregate: services_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "service_type"
"""
enum service_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  service_type_pkey
}

enum service_type_enum {
  OFFER
  WANT
}

"""
Boolean expression to compare columns of type "service_type_enum". All fields are combined with logical 'AND'.
"""
input service_type_enum_comparison_exp {
  _eq: service_type_enum
  _in: [service_type_enum!]
  _is_null: Boolean
  _neq: service_type_enum
  _nin: [service_type_enum!]
}

"""
input type for inserting data into table "service_type"
"""
input service_type_insert_input {
  services: services_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type service_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type service_type_min_fields {
  value: String
}

"""
response of any mutation on the table "service_type"
"""
type service_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [service_type!]!
}

"""
input type for inserting object relation for remote table "service_type"
"""
input service_type_obj_rel_insert_input {
  data: service_type_insert_input!

  """upsert condition"""
  on_conflict: service_type_on_conflict
}

"""
on_conflict condition type for table "service_type"
"""
input service_type_on_conflict {
  constraint: service_type_constraint!
  update_columns: [service_type_update_column!]! = []
  where: service_type_bool_exp
}

"""Ordering options when selecting data from "service_type"."""
input service_type_order_by {
  services_aggregate: services_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: service_type"""
input service_type_pk_columns_input {
  value: String!
}

"""
select columns of table "service_type"
"""
enum service_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "service_type"
"""
input service_type_set_input {
  value: String
}

"""
Streaming cursor of the table "service_type"
"""
input service_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: service_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input service_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "service_type"
"""
enum service_type_update_column {
  """column name"""
  value
}

input service_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: service_type_set_input

  """filter the rows which have to be updated"""
  where: service_type_bool_exp!
}

"""
columns and relationships of "services"
"""
type services {
  created_at: timestamp!
  geo: point
  id: Int!
  location_name: String!
  marketplace: Int!

  """An object relationship"""
  marketplaceByMarketplace: marketplaces!

  """An object relationship"""
  serviceAcceptedPaymentByServiceAcceptedPayment: service_accepted_payment!

  """An object relationship"""
  serviceTypeByServiceType: service_type!
  service_accepted_payment: Int!
  service_available: Boolean
  service_description: String!
  service_type: service_type_enum!

  """An array relationship"""
  services_images(
    """distinct select on columns"""
    distinct_on: [services_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_images_order_by!]

    """filter the rows returned"""
    where: services_images_bool_exp
  ): [services_images!]!

  """An aggregate relationship"""
  services_images_aggregate(
    """distinct select on columns"""
    distinct_on: [services_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_images_order_by!]

    """filter the rows returned"""
    where: services_images_bool_exp
  ): services_images_aggregate!

  """An array relationship"""
  services_ratings(
    """distinct select on columns"""
    distinct_on: [services_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_ratings_order_by!]

    """filter the rows returned"""
    where: services_ratings_bool_exp
  ): [services_ratings!]!

  """An aggregate relationship"""
  services_ratings_aggregate(
    """distinct select on columns"""
    distinct_on: [services_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_ratings_order_by!]

    """filter the rows returned"""
    where: services_ratings_bool_exp
  ): services_ratings_aggregate!
}

"""
aggregated selection of "services"
"""
type services_aggregate {
  aggregate: services_aggregate_fields
  nodes: [services!]!
}

input services_aggregate_bool_exp {
  bool_and: services_aggregate_bool_exp_bool_and
  bool_or: services_aggregate_bool_exp_bool_or
  count: services_aggregate_bool_exp_count
}

input services_aggregate_bool_exp_bool_and {
  arguments: services_select_column_services_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: services_bool_exp
  predicate: Boolean_comparison_exp!
}

input services_aggregate_bool_exp_bool_or {
  arguments: services_select_column_services_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: services_bool_exp
  predicate: Boolean_comparison_exp!
}

input services_aggregate_bool_exp_count {
  arguments: [services_select_column!]
  distinct: Boolean
  filter: services_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "services"
"""
type services_aggregate_fields {
  avg: services_avg_fields
  count(columns: [services_select_column!], distinct: Boolean): Int!
  max: services_max_fields
  min: services_min_fields
  stddev: services_stddev_fields
  stddev_pop: services_stddev_pop_fields
  stddev_samp: services_stddev_samp_fields
  sum: services_sum_fields
  var_pop: services_var_pop_fields
  var_samp: services_var_samp_fields
  variance: services_variance_fields
}

"""
order by aggregate values of table "services"
"""
input services_aggregate_order_by {
  avg: services_avg_order_by
  count: order_by
  max: services_max_order_by
  min: services_min_order_by
  stddev: services_stddev_order_by
  stddev_pop: services_stddev_pop_order_by
  stddev_samp: services_stddev_samp_order_by
  sum: services_sum_order_by
  var_pop: services_var_pop_order_by
  var_samp: services_var_samp_order_by
  variance: services_variance_order_by
}

"""
input type for inserting array relation for remote table "services"
"""
input services_arr_rel_insert_input {
  data: [services_insert_input!]!

  """upsert condition"""
  on_conflict: services_on_conflict
}

"""aggregate avg on columns"""
type services_avg_fields {
  id: Float
  marketplace: Float
  service_accepted_payment: Float
}

"""
order by avg() on columns of table "services"
"""
input services_avg_order_by {
  id: order_by
  marketplace: order_by
  service_accepted_payment: order_by
}

"""
Boolean expression to filter rows from the table "services". All fields are combined with a logical 'AND'.
"""
input services_bool_exp {
  _and: [services_bool_exp!]
  _not: services_bool_exp
  _or: [services_bool_exp!]
  created_at: timestamp_comparison_exp
  geo: point_comparison_exp
  id: Int_comparison_exp
  location_name: String_comparison_exp
  marketplace: Int_comparison_exp
  marketplaceByMarketplace: marketplaces_bool_exp
  serviceAcceptedPaymentByServiceAcceptedPayment: service_accepted_payment_bool_exp
  serviceTypeByServiceType: service_type_bool_exp
  service_accepted_payment: Int_comparison_exp
  service_available: Boolean_comparison_exp
  service_description: String_comparison_exp
  service_type: service_type_enum_comparison_exp
  services_images: services_images_bool_exp
  services_images_aggregate: services_images_aggregate_bool_exp
  services_ratings: services_ratings_bool_exp
  services_ratings_aggregate: services_ratings_aggregate_bool_exp
}

"""
unique or primary key constraints on table "services"
"""
enum services_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  services_pkey
}

"""
columns and relationships of "services_images"
"""
type services_images {
  id: Int!

  """An object relationship"""
  service: services
  service_id: Int
  url_pointer: String!
}

"""
aggregated selection of "services_images"
"""
type services_images_aggregate {
  aggregate: services_images_aggregate_fields
  nodes: [services_images!]!
}

input services_images_aggregate_bool_exp {
  count: services_images_aggregate_bool_exp_count
}

input services_images_aggregate_bool_exp_count {
  arguments: [services_images_select_column!]
  distinct: Boolean
  filter: services_images_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "services_images"
"""
type services_images_aggregate_fields {
  avg: services_images_avg_fields
  count(columns: [services_images_select_column!], distinct: Boolean): Int!
  max: services_images_max_fields
  min: services_images_min_fields
  stddev: services_images_stddev_fields
  stddev_pop: services_images_stddev_pop_fields
  stddev_samp: services_images_stddev_samp_fields
  sum: services_images_sum_fields
  var_pop: services_images_var_pop_fields
  var_samp: services_images_var_samp_fields
  variance: services_images_variance_fields
}

"""
order by aggregate values of table "services_images"
"""
input services_images_aggregate_order_by {
  avg: services_images_avg_order_by
  count: order_by
  max: services_images_max_order_by
  min: services_images_min_order_by
  stddev: services_images_stddev_order_by
  stddev_pop: services_images_stddev_pop_order_by
  stddev_samp: services_images_stddev_samp_order_by
  sum: services_images_sum_order_by
  var_pop: services_images_var_pop_order_by
  var_samp: services_images_var_samp_order_by
  variance: services_images_variance_order_by
}

"""
input type for inserting array relation for remote table "services_images"
"""
input services_images_arr_rel_insert_input {
  data: [services_images_insert_input!]!

  """upsert condition"""
  on_conflict: services_images_on_conflict
}

"""aggregate avg on columns"""
type services_images_avg_fields {
  id: Float
  service_id: Float
}

"""
order by avg() on columns of table "services_images"
"""
input services_images_avg_order_by {
  id: order_by
  service_id: order_by
}

"""
Boolean expression to filter rows from the table "services_images". All fields are combined with a logical 'AND'.
"""
input services_images_bool_exp {
  _and: [services_images_bool_exp!]
  _not: services_images_bool_exp
  _or: [services_images_bool_exp!]
  id: Int_comparison_exp
  service: services_bool_exp
  service_id: Int_comparison_exp
  url_pointer: String_comparison_exp
}

"""
unique or primary key constraints on table "services_images"
"""
enum services_images_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  services_images_pkey
}

"""
input type for incrementing numeric columns in table "services_images"
"""
input services_images_inc_input {
  service_id: Int
}

"""
input type for inserting data into table "services_images"
"""
input services_images_insert_input {
  service: services_obj_rel_insert_input
  service_id: Int
  url_pointer: String
}

"""aggregate max on columns"""
type services_images_max_fields {
  id: Int
  service_id: Int
  url_pointer: String
}

"""
order by max() on columns of table "services_images"
"""
input services_images_max_order_by {
  id: order_by
  service_id: order_by
  url_pointer: order_by
}

"""aggregate min on columns"""
type services_images_min_fields {
  id: Int
  service_id: Int
  url_pointer: String
}

"""
order by min() on columns of table "services_images"
"""
input services_images_min_order_by {
  id: order_by
  service_id: order_by
  url_pointer: order_by
}

"""
response of any mutation on the table "services_images"
"""
type services_images_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [services_images!]!
}

"""
on_conflict condition type for table "services_images"
"""
input services_images_on_conflict {
  constraint: services_images_constraint!
  update_columns: [services_images_update_column!]! = []
  where: services_images_bool_exp
}

"""Ordering options when selecting data from "services_images"."""
input services_images_order_by {
  id: order_by
  service: services_order_by
  service_id: order_by
  url_pointer: order_by
}

"""primary key columns input for table: services_images"""
input services_images_pk_columns_input {
  id: Int!
}

"""
select columns of table "services_images"
"""
enum services_images_select_column {
  """column name"""
  id

  """column name"""
  service_id

  """column name"""
  url_pointer
}

"""
input type for updating data in table "services_images"
"""
input services_images_set_input {
  service_id: Int
  url_pointer: String
}

"""aggregate stddev on columns"""
type services_images_stddev_fields {
  id: Float
  service_id: Float
}

"""
order by stddev() on columns of table "services_images"
"""
input services_images_stddev_order_by {
  id: order_by
  service_id: order_by
}

"""aggregate stddev_pop on columns"""
type services_images_stddev_pop_fields {
  id: Float
  service_id: Float
}

"""
order by stddev_pop() on columns of table "services_images"
"""
input services_images_stddev_pop_order_by {
  id: order_by
  service_id: order_by
}

"""aggregate stddev_samp on columns"""
type services_images_stddev_samp_fields {
  id: Float
  service_id: Float
}

"""
order by stddev_samp() on columns of table "services_images"
"""
input services_images_stddev_samp_order_by {
  id: order_by
  service_id: order_by
}

"""
Streaming cursor of the table "services_images"
"""
input services_images_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: services_images_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input services_images_stream_cursor_value_input {
  id: Int
  service_id: Int
  url_pointer: String
}

"""aggregate sum on columns"""
type services_images_sum_fields {
  id: Int
  service_id: Int
}

"""
order by sum() on columns of table "services_images"
"""
input services_images_sum_order_by {
  id: order_by
  service_id: order_by
}

"""
update columns of table "services_images"
"""
enum services_images_update_column {
  """column name"""
  service_id

  """column name"""
  url_pointer
}

input services_images_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: services_images_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: services_images_set_input

  """filter the rows which have to be updated"""
  where: services_images_bool_exp!
}

"""aggregate var_pop on columns"""
type services_images_var_pop_fields {
  id: Float
  service_id: Float
}

"""
order by var_pop() on columns of table "services_images"
"""
input services_images_var_pop_order_by {
  id: order_by
  service_id: order_by
}

"""aggregate var_samp on columns"""
type services_images_var_samp_fields {
  id: Float
  service_id: Float
}

"""
order by var_samp() on columns of table "services_images"
"""
input services_images_var_samp_order_by {
  id: order_by
  service_id: order_by
}

"""aggregate variance on columns"""
type services_images_variance_fields {
  id: Float
  service_id: Float
}

"""
order by variance() on columns of table "services_images"
"""
input services_images_variance_order_by {
  id: order_by
  service_id: order_by
}

"""
input type for incrementing numeric columns in table "services"
"""
input services_inc_input {
  marketplace: Int
  service_accepted_payment: Int
}

"""
input type for inserting data into table "services"
"""
input services_insert_input {
  created_at: timestamp
  geo: point
  location_name: String
  marketplace: Int
  marketplaceByMarketplace: marketplaces_obj_rel_insert_input
  serviceAcceptedPaymentByServiceAcceptedPayment: service_accepted_payment_obj_rel_insert_input
  serviceTypeByServiceType: service_type_obj_rel_insert_input
  service_accepted_payment: Int
  service_available: Boolean
  service_description: String
  service_type: service_type_enum
  services_images: services_images_arr_rel_insert_input
  services_ratings: services_ratings_arr_rel_insert_input
}

"""aggregate max on columns"""
type services_max_fields {
  created_at: timestamp
  id: Int
  location_name: String
  marketplace: Int
  service_accepted_payment: Int
  service_description: String
}

"""
order by max() on columns of table "services"
"""
input services_max_order_by {
  created_at: order_by
  id: order_by
  location_name: order_by
  marketplace: order_by
  service_accepted_payment: order_by
  service_description: order_by
}

"""aggregate min on columns"""
type services_min_fields {
  created_at: timestamp
  id: Int
  location_name: String
  marketplace: Int
  service_accepted_payment: Int
  service_description: String
}

"""
order by min() on columns of table "services"
"""
input services_min_order_by {
  created_at: order_by
  id: order_by
  location_name: order_by
  marketplace: order_by
  service_accepted_payment: order_by
  service_description: order_by
}

"""
response of any mutation on the table "services"
"""
type services_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [services!]!
}

"""
input type for inserting object relation for remote table "services"
"""
input services_obj_rel_insert_input {
  data: services_insert_input!

  """upsert condition"""
  on_conflict: services_on_conflict
}

"""
on_conflict condition type for table "services"
"""
input services_on_conflict {
  constraint: services_constraint!
  update_columns: [services_update_column!]! = []
  where: services_bool_exp
}

"""Ordering options when selecting data from "services"."""
input services_order_by {
  created_at: order_by
  geo: order_by
  id: order_by
  location_name: order_by
  marketplace: order_by
  marketplaceByMarketplace: marketplaces_order_by
  serviceAcceptedPaymentByServiceAcceptedPayment: service_accepted_payment_order_by
  serviceTypeByServiceType: service_type_order_by
  service_accepted_payment: order_by
  service_available: order_by
  service_description: order_by
  service_type: order_by
  services_images_aggregate: services_images_aggregate_order_by
  services_ratings_aggregate: services_ratings_aggregate_order_by
}

"""primary key columns input for table: services"""
input services_pk_columns_input {
  id: Int!
}

"""
columns and relationships of "services_ratings"
"""
type services_ratings {
  """An object relationship"""
  account: accounts!
  created_at: timestamp!
  id: Int!
  rating_by: Int!
  score: Int!

  """An object relationship"""
  service: services!
  service_id: Int!
}

"""
aggregated selection of "services_ratings"
"""
type services_ratings_aggregate {
  aggregate: services_ratings_aggregate_fields
  nodes: [services_ratings!]!
}

input services_ratings_aggregate_bool_exp {
  count: services_ratings_aggregate_bool_exp_count
}

input services_ratings_aggregate_bool_exp_count {
  arguments: [services_ratings_select_column!]
  distinct: Boolean
  filter: services_ratings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "services_ratings"
"""
type services_ratings_aggregate_fields {
  avg: services_ratings_avg_fields
  count(columns: [services_ratings_select_column!], distinct: Boolean): Int!
  max: services_ratings_max_fields
  min: services_ratings_min_fields
  stddev: services_ratings_stddev_fields
  stddev_pop: services_ratings_stddev_pop_fields
  stddev_samp: services_ratings_stddev_samp_fields
  sum: services_ratings_sum_fields
  var_pop: services_ratings_var_pop_fields
  var_samp: services_ratings_var_samp_fields
  variance: services_ratings_variance_fields
}

"""
order by aggregate values of table "services_ratings"
"""
input services_ratings_aggregate_order_by {
  avg: services_ratings_avg_order_by
  count: order_by
  max: services_ratings_max_order_by
  min: services_ratings_min_order_by
  stddev: services_ratings_stddev_order_by
  stddev_pop: services_ratings_stddev_pop_order_by
  stddev_samp: services_ratings_stddev_samp_order_by
  sum: services_ratings_sum_order_by
  var_pop: services_ratings_var_pop_order_by
  var_samp: services_ratings_var_samp_order_by
  variance: services_ratings_variance_order_by
}

"""
input type for inserting array relation for remote table "services_ratings"
"""
input services_ratings_arr_rel_insert_input {
  data: [services_ratings_insert_input!]!

  """upsert condition"""
  on_conflict: services_ratings_on_conflict
}

"""aggregate avg on columns"""
type services_ratings_avg_fields {
  id: Float
  rating_by: Float
  score: Float
  service_id: Float
}

"""
order by avg() on columns of table "services_ratings"
"""
input services_ratings_avg_order_by {
  id: order_by
  rating_by: order_by
  score: order_by
  service_id: order_by
}

"""
Boolean expression to filter rows from the table "services_ratings". All fields are combined with a logical 'AND'.
"""
input services_ratings_bool_exp {
  _and: [services_ratings_bool_exp!]
  _not: services_ratings_bool_exp
  _or: [services_ratings_bool_exp!]
  account: accounts_bool_exp
  created_at: timestamp_comparison_exp
  id: Int_comparison_exp
  rating_by: Int_comparison_exp
  score: Int_comparison_exp
  service: services_bool_exp
  service_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "services_ratings"
"""
enum services_ratings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  services_ratings_pkey
}

"""
input type for incrementing numeric columns in table "services_ratings"
"""
input services_ratings_inc_input {
  rating_by: Int
  score: Int
  service_id: Int
}

"""
input type for inserting data into table "services_ratings"
"""
input services_ratings_insert_input {
  account: accounts_obj_rel_insert_input
  created_at: timestamp
  rating_by: Int
  score: Int
  service: services_obj_rel_insert_input
  service_id: Int
}

"""aggregate max on columns"""
type services_ratings_max_fields {
  created_at: timestamp
  id: Int
  rating_by: Int
  score: Int
  service_id: Int
}

"""
order by max() on columns of table "services_ratings"
"""
input services_ratings_max_order_by {
  created_at: order_by
  id: order_by
  rating_by: order_by
  score: order_by
  service_id: order_by
}

"""aggregate min on columns"""
type services_ratings_min_fields {
  created_at: timestamp
  id: Int
  rating_by: Int
  score: Int
  service_id: Int
}

"""
order by min() on columns of table "services_ratings"
"""
input services_ratings_min_order_by {
  created_at: order_by
  id: order_by
  rating_by: order_by
  score: order_by
  service_id: order_by
}

"""
response of any mutation on the table "services_ratings"
"""
type services_ratings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [services_ratings!]!
}

"""
on_conflict condition type for table "services_ratings"
"""
input services_ratings_on_conflict {
  constraint: services_ratings_constraint!
  update_columns: [services_ratings_update_column!]! = []
  where: services_ratings_bool_exp
}

"""Ordering options when selecting data from "services_ratings"."""
input services_ratings_order_by {
  account: accounts_order_by
  created_at: order_by
  id: order_by
  rating_by: order_by
  score: order_by
  service: services_order_by
  service_id: order_by
}

"""primary key columns input for table: services_ratings"""
input services_ratings_pk_columns_input {
  id: Int!
}

"""
select columns of table "services_ratings"
"""
enum services_ratings_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  rating_by

  """column name"""
  score

  """column name"""
  service_id
}

"""
input type for updating data in table "services_ratings"
"""
input services_ratings_set_input {
  created_at: timestamp
  rating_by: Int
  score: Int
  service_id: Int
}

"""aggregate stddev on columns"""
type services_ratings_stddev_fields {
  id: Float
  rating_by: Float
  score: Float
  service_id: Float
}

"""
order by stddev() on columns of table "services_ratings"
"""
input services_ratings_stddev_order_by {
  id: order_by
  rating_by: order_by
  score: order_by
  service_id: order_by
}

"""aggregate stddev_pop on columns"""
type services_ratings_stddev_pop_fields {
  id: Float
  rating_by: Float
  score: Float
  service_id: Float
}

"""
order by stddev_pop() on columns of table "services_ratings"
"""
input services_ratings_stddev_pop_order_by {
  id: order_by
  rating_by: order_by
  score: order_by
  service_id: order_by
}

"""aggregate stddev_samp on columns"""
type services_ratings_stddev_samp_fields {
  id: Float
  rating_by: Float
  score: Float
  service_id: Float
}

"""
order by stddev_samp() on columns of table "services_ratings"
"""
input services_ratings_stddev_samp_order_by {
  id: order_by
  rating_by: order_by
  score: order_by
  service_id: order_by
}

"""
Streaming cursor of the table "services_ratings"
"""
input services_ratings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: services_ratings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input services_ratings_stream_cursor_value_input {
  created_at: timestamp
  id: Int
  rating_by: Int
  score: Int
  service_id: Int
}

"""aggregate sum on columns"""
type services_ratings_sum_fields {
  id: Int
  rating_by: Int
  score: Int
  service_id: Int
}

"""
order by sum() on columns of table "services_ratings"
"""
input services_ratings_sum_order_by {
  id: order_by
  rating_by: order_by
  score: order_by
  service_id: order_by
}

"""
update columns of table "services_ratings"
"""
enum services_ratings_update_column {
  """column name"""
  created_at

  """column name"""
  rating_by

  """column name"""
  score

  """column name"""
  service_id
}

input services_ratings_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: services_ratings_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: services_ratings_set_input

  """filter the rows which have to be updated"""
  where: services_ratings_bool_exp!
}

"""aggregate var_pop on columns"""
type services_ratings_var_pop_fields {
  id: Float
  rating_by: Float
  score: Float
  service_id: Float
}

"""
order by var_pop() on columns of table "services_ratings"
"""
input services_ratings_var_pop_order_by {
  id: order_by
  rating_by: order_by
  score: order_by
  service_id: order_by
}

"""aggregate var_samp on columns"""
type services_ratings_var_samp_fields {
  id: Float
  rating_by: Float
  score: Float
  service_id: Float
}

"""
order by var_samp() on columns of table "services_ratings"
"""
input services_ratings_var_samp_order_by {
  id: order_by
  rating_by: order_by
  score: order_by
  service_id: order_by
}

"""aggregate variance on columns"""
type services_ratings_variance_fields {
  id: Float
  rating_by: Float
  score: Float
  service_id: Float
}

"""
order by variance() on columns of table "services_ratings"
"""
input services_ratings_variance_order_by {
  id: order_by
  rating_by: order_by
  score: order_by
  service_id: order_by
}

"""
select columns of table "services"
"""
enum services_select_column {
  """column name"""
  created_at

  """column name"""
  geo

  """column name"""
  id

  """column name"""
  location_name

  """column name"""
  marketplace

  """column name"""
  service_accepted_payment

  """column name"""
  service_available

  """column name"""
  service_description

  """column name"""
  service_type
}

"""
select "services_aggregate_bool_exp_bool_and_arguments_columns" columns of table "services"
"""
enum services_select_column_services_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  service_available
}

"""
select "services_aggregate_bool_exp_bool_or_arguments_columns" columns of table "services"
"""
enum services_select_column_services_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  service_available
}

"""
input type for updating data in table "services"
"""
input services_set_input {
  created_at: timestamp
  geo: point
  location_name: String
  marketplace: Int
  service_accepted_payment: Int
  service_available: Boolean
  service_description: String
  service_type: service_type_enum
}

"""aggregate stddev on columns"""
type services_stddev_fields {
  id: Float
  marketplace: Float
  service_accepted_payment: Float
}

"""
order by stddev() on columns of table "services"
"""
input services_stddev_order_by {
  id: order_by
  marketplace: order_by
  service_accepted_payment: order_by
}

"""aggregate stddev_pop on columns"""
type services_stddev_pop_fields {
  id: Float
  marketplace: Float
  service_accepted_payment: Float
}

"""
order by stddev_pop() on columns of table "services"
"""
input services_stddev_pop_order_by {
  id: order_by
  marketplace: order_by
  service_accepted_payment: order_by
}

"""aggregate stddev_samp on columns"""
type services_stddev_samp_fields {
  id: Float
  marketplace: Float
  service_accepted_payment: Float
}

"""
order by stddev_samp() on columns of table "services"
"""
input services_stddev_samp_order_by {
  id: order_by
  marketplace: order_by
  service_accepted_payment: order_by
}

"""
Streaming cursor of the table "services"
"""
input services_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: services_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input services_stream_cursor_value_input {
  created_at: timestamp
  geo: point
  id: Int
  location_name: String
  marketplace: Int
  service_accepted_payment: Int
  service_available: Boolean
  service_description: String
  service_type: service_type_enum
}

"""aggregate sum on columns"""
type services_sum_fields {
  id: Int
  marketplace: Int
  service_accepted_payment: Int
}

"""
order by sum() on columns of table "services"
"""
input services_sum_order_by {
  id: order_by
  marketplace: order_by
  service_accepted_payment: order_by
}

"""
update columns of table "services"
"""
enum services_update_column {
  """column name"""
  created_at

  """column name"""
  geo

  """column name"""
  location_name

  """column name"""
  marketplace

  """column name"""
  service_accepted_payment

  """column name"""
  service_available

  """column name"""
  service_description

  """column name"""
  service_type
}

input services_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: services_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: services_set_input

  """filter the rows which have to be updated"""
  where: services_bool_exp!
}

"""aggregate var_pop on columns"""
type services_var_pop_fields {
  id: Float
  marketplace: Float
  service_accepted_payment: Float
}

"""
order by var_pop() on columns of table "services"
"""
input services_var_pop_order_by {
  id: order_by
  marketplace: order_by
  service_accepted_payment: order_by
}

"""aggregate var_samp on columns"""
type services_var_samp_fields {
  id: Float
  marketplace: Float
  service_accepted_payment: Float
}

"""
order by var_samp() on columns of table "services"
"""
input services_var_samp_order_by {
  id: order_by
  marketplace: order_by
  service_accepted_payment: order_by
}

"""aggregate variance on columns"""
type services_variance_fields {
  id: Float
  marketplace: Float
  service_accepted_payment: Float
}

"""
order by variance() on columns of table "services"
"""
input services_variance_order_by {
  id: order_by
  marketplace: order_by
  service_accepted_payment: order_by
}

type subscription_root {
  """
  fetch data from the table: "account_type"
  """
  account_type(
    """distinct select on columns"""
    distinct_on: [account_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_type_order_by!]

    """filter the rows returned"""
    where: account_type_bool_exp
  ): [account_type!]!

  """
  fetch aggregated fields from the table: "account_type"
  """
  account_type_aggregate(
    """distinct select on columns"""
    distinct_on: [account_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [account_type_order_by!]

    """filter the rows returned"""
    where: account_type_bool_exp
  ): account_type_aggregate!

  """fetch data from the table: "account_type" using primary key columns"""
  account_type_by_pk(value: String!): account_type

  """
  fetch data from the table in a streaming manner: "account_type"
  """
  account_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [account_type_stream_cursor_input]!

    """filter the rows returned"""
    where: account_type_bool_exp
  ): [account_type!]!

  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): accounts_aggregate!

  """fetch data from the table: "accounts" using primary key columns"""
  accounts_by_pk(id: Int!): accounts

  """
  fetch data from the table in a streaming manner: "accounts"
  """
  accounts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [accounts_stream_cursor_input]!

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """
  fetch data from the table: "gender_type"
  """
  gender_type(
    """distinct select on columns"""
    distinct_on: [gender_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_type_order_by!]

    """filter the rows returned"""
    where: gender_type_bool_exp
  ): [gender_type!]!

  """
  fetch aggregated fields from the table: "gender_type"
  """
  gender_type_aggregate(
    """distinct select on columns"""
    distinct_on: [gender_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gender_type_order_by!]

    """filter the rows returned"""
    where: gender_type_bool_exp
  ): gender_type_aggregate!

  """fetch data from the table: "gender_type" using primary key columns"""
  gender_type_by_pk(value: String!): gender_type

  """
  fetch data from the table in a streaming manner: "gender_type"
  """
  gender_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [gender_type_stream_cursor_input]!

    """filter the rows returned"""
    where: gender_type_bool_exp
  ): [gender_type!]!

  """
  fetch data from the table: "interface_type"
  """
  interface_type(
    """distinct select on columns"""
    distinct_on: [interface_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interface_type_order_by!]

    """filter the rows returned"""
    where: interface_type_bool_exp
  ): [interface_type!]!

  """
  fetch aggregated fields from the table: "interface_type"
  """
  interface_type_aggregate(
    """distinct select on columns"""
    distinct_on: [interface_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [interface_type_order_by!]

    """filter the rows returned"""
    where: interface_type_bool_exp
  ): interface_type_aggregate!

  """fetch data from the table: "interface_type" using primary key columns"""
  interface_type_by_pk(value: String!): interface_type

  """
  fetch data from the table in a streaming manner: "interface_type"
  """
  interface_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [interface_type_stream_cursor_input]!

    """filter the rows returned"""
    where: interface_type_bool_exp
  ): [interface_type!]!

  """
  fetch data from the table: "marketplaces"
  """
  marketplaces(
    """distinct select on columns"""
    distinct_on: [marketplaces_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [marketplaces_order_by!]

    """filter the rows returned"""
    where: marketplaces_bool_exp
  ): [marketplaces!]!

  """
  fetch aggregated fields from the table: "marketplaces"
  """
  marketplaces_aggregate(
    """distinct select on columns"""
    distinct_on: [marketplaces_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [marketplaces_order_by!]

    """filter the rows returned"""
    where: marketplaces_bool_exp
  ): marketplaces_aggregate!

  """fetch data from the table: "marketplaces" using primary key columns"""
  marketplaces_by_pk(id: Int!): marketplaces

  """
  fetch data from the table in a streaming manner: "marketplaces"
  """
  marketplaces_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [marketplaces_stream_cursor_input]!

    """filter the rows returned"""
    where: marketplaces_bool_exp
  ): [marketplaces!]!

  """
  fetch data from the table: "personal_information"
  """
  personal_information(
    """distinct select on columns"""
    distinct_on: [personal_information_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [personal_information_order_by!]

    """filter the rows returned"""
    where: personal_information_bool_exp
  ): [personal_information!]!

  """
  fetch aggregated fields from the table: "personal_information"
  """
  personal_information_aggregate(
    """distinct select on columns"""
    distinct_on: [personal_information_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [personal_information_order_by!]

    """filter the rows returned"""
    where: personal_information_bool_exp
  ): personal_information_aggregate!

  """
  fetch data from the table in a streaming manner: "personal_information"
  """
  personal_information_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [personal_information_stream_cursor_input]!

    """filter the rows returned"""
    where: personal_information_bool_exp
  ): [personal_information!]!

  """
  fetch data from the table: "service_accepted_payment"
  """
  service_accepted_payment(
    """distinct select on columns"""
    distinct_on: [service_accepted_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_accepted_payment_order_by!]

    """filter the rows returned"""
    where: service_accepted_payment_bool_exp
  ): [service_accepted_payment!]!

  """
  fetch aggregated fields from the table: "service_accepted_payment"
  """
  service_accepted_payment_aggregate(
    """distinct select on columns"""
    distinct_on: [service_accepted_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_accepted_payment_order_by!]

    """filter the rows returned"""
    where: service_accepted_payment_bool_exp
  ): service_accepted_payment_aggregate!

  """
  fetch data from the table: "service_accepted_payment" using primary key columns
  """
  service_accepted_payment_by_pk(id: Int!): service_accepted_payment

  """
  fetch data from the table in a streaming manner: "service_accepted_payment"
  """
  service_accepted_payment_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_accepted_payment_stream_cursor_input]!

    """filter the rows returned"""
    where: service_accepted_payment_bool_exp
  ): [service_accepted_payment!]!

  """
  fetch data from the table: "service_type"
  """
  service_type(
    """distinct select on columns"""
    distinct_on: [service_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_type_order_by!]

    """filter the rows returned"""
    where: service_type_bool_exp
  ): [service_type!]!

  """
  fetch aggregated fields from the table: "service_type"
  """
  service_type_aggregate(
    """distinct select on columns"""
    distinct_on: [service_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_type_order_by!]

    """filter the rows returned"""
    where: service_type_bool_exp
  ): service_type_aggregate!

  """fetch data from the table: "service_type" using primary key columns"""
  service_type_by_pk(value: String!): service_type

  """
  fetch data from the table in a streaming manner: "service_type"
  """
  service_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [service_type_stream_cursor_input]!

    """filter the rows returned"""
    where: service_type_bool_exp
  ): [service_type!]!

  """An array relationship"""
  services(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """An aggregate relationship"""
  services_aggregate(
    """distinct select on columns"""
    distinct_on: [services_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_order_by!]

    """filter the rows returned"""
    where: services_bool_exp
  ): services_aggregate!

  """fetch data from the table: "services" using primary key columns"""
  services_by_pk(id: Int!): services

  """An array relationship"""
  services_images(
    """distinct select on columns"""
    distinct_on: [services_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_images_order_by!]

    """filter the rows returned"""
    where: services_images_bool_exp
  ): [services_images!]!

  """An aggregate relationship"""
  services_images_aggregate(
    """distinct select on columns"""
    distinct_on: [services_images_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_images_order_by!]

    """filter the rows returned"""
    where: services_images_bool_exp
  ): services_images_aggregate!

  """fetch data from the table: "services_images" using primary key columns"""
  services_images_by_pk(id: Int!): services_images

  """
  fetch data from the table in a streaming manner: "services_images"
  """
  services_images_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [services_images_stream_cursor_input]!

    """filter the rows returned"""
    where: services_images_bool_exp
  ): [services_images!]!

  """An array relationship"""
  services_ratings(
    """distinct select on columns"""
    distinct_on: [services_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_ratings_order_by!]

    """filter the rows returned"""
    where: services_ratings_bool_exp
  ): [services_ratings!]!

  """An aggregate relationship"""
  services_ratings_aggregate(
    """distinct select on columns"""
    distinct_on: [services_ratings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [services_ratings_order_by!]

    """filter the rows returned"""
    where: services_ratings_bool_exp
  ): services_ratings_aggregate!

  """
  fetch data from the table: "services_ratings" using primary key columns
  """
  services_ratings_by_pk(id: Int!): services_ratings

  """
  fetch data from the table in a streaming manner: "services_ratings"
  """
  services_ratings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [services_ratings_stream_cursor_input]!

    """filter the rows returned"""
    where: services_ratings_bool_exp
  ): [services_ratings!]!

  """
  fetch data from the table in a streaming manner: "services"
  """
  services_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [services_stream_cursor_input]!

    """filter the rows returned"""
    where: services_bool_exp
  ): [services!]!

  """
  fetch data from the table: "till"
  """
  till(
    """distinct select on columns"""
    distinct_on: [till_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [till_order_by!]

    """filter the rows returned"""
    where: till_bool_exp
  ): [till!]!

  """
  fetch aggregated fields from the table: "till"
  """
  till_aggregate(
    """distinct select on columns"""
    distinct_on: [till_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [till_order_by!]

    """filter the rows returned"""
    where: till_bool_exp
  ): till_aggregate!

  """fetch data from the table: "till" using primary key columns"""
  till_by_pk(id: Int!): till

  """
  fetch data from the table in a streaming manner: "till"
  """
  till_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [till_stream_cursor_input]!

    """filter the rows returned"""
    where: till_bool_exp
  ): [till!]!

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): [transactions!]!

  """An aggregate relationship"""
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): transactions_aggregate!

  """fetch data from the table: "transactions" using primary key columns"""
  transactions_by_pk(id: Int!): transactions

  """
  fetch data from the table in a streaming manner: "transactions"
  """
  transactions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [transactions_stream_cursor_input]!

    """filter the rows returned"""
    where: transactions_bool_exp
  ): [transactions!]!

  """
  fetch data from the table: "tx_type"
  """
  tx_type(
    """distinct select on columns"""
    distinct_on: [tx_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tx_type_order_by!]

    """filter the rows returned"""
    where: tx_type_bool_exp
  ): [tx_type!]!

  """
  fetch aggregated fields from the table: "tx_type"
  """
  tx_type_aggregate(
    """distinct select on columns"""
    distinct_on: [tx_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [tx_type_order_by!]

    """filter the rows returned"""
    where: tx_type_bool_exp
  ): tx_type_aggregate!

  """fetch data from the table: "tx_type" using primary key columns"""
  tx_type_by_pk(value: String!): tx_type

  """
  fetch data from the table in a streaming manner: "tx_type"
  """
  tx_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [tx_type_stream_cursor_input]!

    """filter the rows returned"""
    where: tx_type_bool_exp
  ): [tx_type!]!

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: Int!): users

  """
  fetch data from the table in a streaming manner: "users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An array relationship"""
  voucher_backers(
    """distinct select on columns"""
    distinct_on: [voucher_backers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_backers_order_by!]

    """filter the rows returned"""
    where: voucher_backers_bool_exp
  ): [voucher_backers!]!

  """An aggregate relationship"""
  voucher_backers_aggregate(
    """distinct select on columns"""
    distinct_on: [voucher_backers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_backers_order_by!]

    """filter the rows returned"""
    where: voucher_backers_bool_exp
  ): voucher_backers_aggregate!

  """fetch data from the table: "voucher_backers" using primary key columns"""
  voucher_backers_by_pk(id: Int!): voucher_backers

  """
  fetch data from the table in a streaming manner: "voucher_backers"
  """
  voucher_backers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [voucher_backers_stream_cursor_input]!

    """filter the rows returned"""
    where: voucher_backers_bool_exp
  ): [voucher_backers!]!

  """An array relationship"""
  voucher_certifications(
    """distinct select on columns"""
    distinct_on: [voucher_certifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_certifications_order_by!]

    """filter the rows returned"""
    where: voucher_certifications_bool_exp
  ): [voucher_certifications!]!

  """An aggregate relationship"""
  voucher_certifications_aggregate(
    """distinct select on columns"""
    distinct_on: [voucher_certifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_certifications_order_by!]

    """filter the rows returned"""
    where: voucher_certifications_bool_exp
  ): voucher_certifications_aggregate!

  """
  fetch data from the table: "voucher_certifications" using primary key columns
  """
  voucher_certifications_by_pk(id: Int!): voucher_certifications

  """
  fetch data from the table in a streaming manner: "voucher_certifications"
  """
  voucher_certifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [voucher_certifications_stream_cursor_input]!

    """filter the rows returned"""
    where: voucher_certifications_bool_exp
  ): [voucher_certifications!]!

  """
  fetch data from the table: "vouchers"
  """
  vouchers(
    """distinct select on columns"""
    distinct_on: [vouchers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vouchers_order_by!]

    """filter the rows returned"""
    where: vouchers_bool_exp
  ): [vouchers!]!

  """
  fetch aggregated fields from the table: "vouchers"
  """
  vouchers_aggregate(
    """distinct select on columns"""
    distinct_on: [vouchers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vouchers_order_by!]

    """filter the rows returned"""
    where: vouchers_bool_exp
  ): vouchers_aggregate!

  """fetch data from the table: "vouchers" using primary key columns"""
  vouchers_by_pk(id: Int!): vouchers

  """
  fetch data from the table in a streaming manner: "vouchers"
  """
  vouchers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [vouchers_stream_cursor_input]!

    """filter the rows returned"""
    where: vouchers_bool_exp
  ): [vouchers!]!

  """
  fetch data from the table: "vpa"
  """
  vpa(
    """distinct select on columns"""
    distinct_on: [vpa_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vpa_order_by!]

    """filter the rows returned"""
    where: vpa_bool_exp
  ): [vpa!]!

  """
  fetch aggregated fields from the table: "vpa"
  """
  vpa_aggregate(
    """distinct select on columns"""
    distinct_on: [vpa_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vpa_order_by!]

    """filter the rows returned"""
    where: vpa_bool_exp
  ): vpa_aggregate!

  """fetch data from the table: "vpa" using primary key columns"""
  vpa_by_pk(id: Int!): vpa

  """
  fetch data from the table in a streaming manner: "vpa"
  """
  vpa_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [vpa_stream_cursor_input]!

    """filter the rows returned"""
    where: vpa_bool_exp
  ): [vpa!]!
}

"""
columns and relationships of "till"
"""
type till {
  """An object relationship"""
  account: accounts!
  created_at: timestamp!
  id: Int!
  linked_account: Int!
  till: String!
}

"""
aggregated selection of "till"
"""
type till_aggregate {
  aggregate: till_aggregate_fields
  nodes: [till!]!
}

input till_aggregate_bool_exp {
  count: till_aggregate_bool_exp_count
}

input till_aggregate_bool_exp_count {
  arguments: [till_select_column!]
  distinct: Boolean
  filter: till_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "till"
"""
type till_aggregate_fields {
  avg: till_avg_fields
  count(columns: [till_select_column!], distinct: Boolean): Int!
  max: till_max_fields
  min: till_min_fields
  stddev: till_stddev_fields
  stddev_pop: till_stddev_pop_fields
  stddev_samp: till_stddev_samp_fields
  sum: till_sum_fields
  var_pop: till_var_pop_fields
  var_samp: till_var_samp_fields
  variance: till_variance_fields
}

"""
order by aggregate values of table "till"
"""
input till_aggregate_order_by {
  avg: till_avg_order_by
  count: order_by
  max: till_max_order_by
  min: till_min_order_by
  stddev: till_stddev_order_by
  stddev_pop: till_stddev_pop_order_by
  stddev_samp: till_stddev_samp_order_by
  sum: till_sum_order_by
  var_pop: till_var_pop_order_by
  var_samp: till_var_samp_order_by
  variance: till_variance_order_by
}

"""
input type for inserting array relation for remote table "till"
"""
input till_arr_rel_insert_input {
  data: [till_insert_input!]!

  """upsert condition"""
  on_conflict: till_on_conflict
}

"""aggregate avg on columns"""
type till_avg_fields {
  id: Float
  linked_account: Float
}

"""
order by avg() on columns of table "till"
"""
input till_avg_order_by {
  id: order_by
  linked_account: order_by
}

"""
Boolean expression to filter rows from the table "till". All fields are combined with a logical 'AND'.
"""
input till_bool_exp {
  _and: [till_bool_exp!]
  _not: till_bool_exp
  _or: [till_bool_exp!]
  account: accounts_bool_exp
  created_at: timestamp_comparison_exp
  id: Int_comparison_exp
  linked_account: Int_comparison_exp
  till: String_comparison_exp
}

"""
unique or primary key constraints on table "till"
"""
enum till_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  till_pkey

  """
  unique or primary key constraint on columns "till"
  """
  till_till_key
}

"""
input type for incrementing numeric columns in table "till"
"""
input till_inc_input {
  linked_account: Int
}

"""
input type for inserting data into table "till"
"""
input till_insert_input {
  account: accounts_obj_rel_insert_input
  created_at: timestamp
  linked_account: Int
  till: String
}

"""aggregate max on columns"""
type till_max_fields {
  created_at: timestamp
  id: Int
  linked_account: Int
  till: String
}

"""
order by max() on columns of table "till"
"""
input till_max_order_by {
  created_at: order_by
  id: order_by
  linked_account: order_by
  till: order_by
}

"""aggregate min on columns"""
type till_min_fields {
  created_at: timestamp
  id: Int
  linked_account: Int
  till: String
}

"""
order by min() on columns of table "till"
"""
input till_min_order_by {
  created_at: order_by
  id: order_by
  linked_account: order_by
  till: order_by
}

"""
response of any mutation on the table "till"
"""
type till_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [till!]!
}

"""
on_conflict condition type for table "till"
"""
input till_on_conflict {
  constraint: till_constraint!
  update_columns: [till_update_column!]! = []
  where: till_bool_exp
}

"""Ordering options when selecting data from "till"."""
input till_order_by {
  account: accounts_order_by
  created_at: order_by
  id: order_by
  linked_account: order_by
  till: order_by
}

"""primary key columns input for table: till"""
input till_pk_columns_input {
  id: Int!
}

"""
select columns of table "till"
"""
enum till_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  linked_account

  """column name"""
  till
}

"""
input type for updating data in table "till"
"""
input till_set_input {
  created_at: timestamp
  linked_account: Int
  till: String
}

"""aggregate stddev on columns"""
type till_stddev_fields {
  id: Float
  linked_account: Float
}

"""
order by stddev() on columns of table "till"
"""
input till_stddev_order_by {
  id: order_by
  linked_account: order_by
}

"""aggregate stddev_pop on columns"""
type till_stddev_pop_fields {
  id: Float
  linked_account: Float
}

"""
order by stddev_pop() on columns of table "till"
"""
input till_stddev_pop_order_by {
  id: order_by
  linked_account: order_by
}

"""aggregate stddev_samp on columns"""
type till_stddev_samp_fields {
  id: Float
  linked_account: Float
}

"""
order by stddev_samp() on columns of table "till"
"""
input till_stddev_samp_order_by {
  id: order_by
  linked_account: order_by
}

"""
Streaming cursor of the table "till"
"""
input till_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: till_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input till_stream_cursor_value_input {
  created_at: timestamp
  id: Int
  linked_account: Int
  till: String
}

"""aggregate sum on columns"""
type till_sum_fields {
  id: Int
  linked_account: Int
}

"""
order by sum() on columns of table "till"
"""
input till_sum_order_by {
  id: order_by
  linked_account: order_by
}

"""
update columns of table "till"
"""
enum till_update_column {
  """column name"""
  created_at

  """column name"""
  linked_account

  """column name"""
  till
}

input till_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: till_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: till_set_input

  """filter the rows which have to be updated"""
  where: till_bool_exp!
}

"""aggregate var_pop on columns"""
type till_var_pop_fields {
  id: Float
  linked_account: Float
}

"""
order by var_pop() on columns of table "till"
"""
input till_var_pop_order_by {
  id: order_by
  linked_account: order_by
}

"""aggregate var_samp on columns"""
type till_var_samp_fields {
  id: Float
  linked_account: Float
}

"""
order by var_samp() on columns of table "till"
"""
input till_var_samp_order_by {
  id: order_by
  linked_account: order_by
}

"""aggregate variance on columns"""
type till_variance_fields {
  id: Float
  linked_account: Float
}

"""
order by variance() on columns of table "till"
"""
input till_variance_order_by {
  id: order_by
  linked_account: order_by
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"""
columns and relationships of "transactions"
"""
type transactions {
  block_number: Int!
  date_block: timestamp!
  id: Int!
  recipient_address: String!
  sender_address: String!
  success: Boolean!

  """An object relationship"""
  txTypeByTxType: tx_type
  tx_hash: String!
  tx_index: Int!
  tx_type: tx_type_enum
  tx_value: bigint!

  """An object relationship"""
  voucher: vouchers!
  voucher_address: String!
}

"""
aggregated selection of "transactions"
"""
type transactions_aggregate {
  aggregate: transactions_aggregate_fields
  nodes: [transactions!]!
}

input transactions_aggregate_bool_exp {
  bool_and: transactions_aggregate_bool_exp_bool_and
  bool_or: transactions_aggregate_bool_exp_bool_or
  count: transactions_aggregate_bool_exp_count
}

input transactions_aggregate_bool_exp_bool_and {
  arguments: transactions_select_column_transactions_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: transactions_bool_exp
  predicate: Boolean_comparison_exp!
}

input transactions_aggregate_bool_exp_bool_or {
  arguments: transactions_select_column_transactions_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: transactions_bool_exp
  predicate: Boolean_comparison_exp!
}

input transactions_aggregate_bool_exp_count {
  arguments: [transactions_select_column!]
  distinct: Boolean
  filter: transactions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "transactions"
"""
type transactions_aggregate_fields {
  avg: transactions_avg_fields
  count(columns: [transactions_select_column!], distinct: Boolean): Int!
  max: transactions_max_fields
  min: transactions_min_fields
  stddev: transactions_stddev_fields
  stddev_pop: transactions_stddev_pop_fields
  stddev_samp: transactions_stddev_samp_fields
  sum: transactions_sum_fields
  var_pop: transactions_var_pop_fields
  var_samp: transactions_var_samp_fields
  variance: transactions_variance_fields
}

"""
order by aggregate values of table "transactions"
"""
input transactions_aggregate_order_by {
  avg: transactions_avg_order_by
  count: order_by
  max: transactions_max_order_by
  min: transactions_min_order_by
  stddev: transactions_stddev_order_by
  stddev_pop: transactions_stddev_pop_order_by
  stddev_samp: transactions_stddev_samp_order_by
  sum: transactions_sum_order_by
  var_pop: transactions_var_pop_order_by
  var_samp: transactions_var_samp_order_by
  variance: transactions_variance_order_by
}

"""
input type for inserting array relation for remote table "transactions"
"""
input transactions_arr_rel_insert_input {
  data: [transactions_insert_input!]!

  """upsert condition"""
  on_conflict: transactions_on_conflict
}

"""aggregate avg on columns"""
type transactions_avg_fields {
  block_number: Float
  id: Float
  tx_index: Float
  tx_value: Float
}

"""
order by avg() on columns of table "transactions"
"""
input transactions_avg_order_by {
  block_number: order_by
  id: order_by
  tx_index: order_by
  tx_value: order_by
}

"""
Boolean expression to filter rows from the table "transactions". All fields are combined with a logical 'AND'.
"""
input transactions_bool_exp {
  _and: [transactions_bool_exp!]
  _not: transactions_bool_exp
  _or: [transactions_bool_exp!]
  block_number: Int_comparison_exp
  date_block: timestamp_comparison_exp
  id: Int_comparison_exp
  recipient_address: String_comparison_exp
  sender_address: String_comparison_exp
  success: Boolean_comparison_exp
  txTypeByTxType: tx_type_bool_exp
  tx_hash: String_comparison_exp
  tx_index: Int_comparison_exp
  tx_type: tx_type_enum_comparison_exp
  tx_value: bigint_comparison_exp
  voucher: vouchers_bool_exp
  voucher_address: String_comparison_exp
}

"""
unique or primary key constraints on table "transactions"
"""
enum transactions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  transactions_pkey

  """
  unique or primary key constraint on columns "tx_hash"
  """
  transactions_tx_hash_key
}

"""
input type for incrementing numeric columns in table "transactions"
"""
input transactions_inc_input {
  block_number: Int
  tx_index: Int
  tx_value: bigint
}

"""
input type for inserting data into table "transactions"
"""
input transactions_insert_input {
  block_number: Int
  date_block: timestamp
  recipient_address: String
  sender_address: String
  success: Boolean
  txTypeByTxType: tx_type_obj_rel_insert_input
  tx_hash: String
  tx_index: Int
  tx_type: tx_type_enum
  tx_value: bigint
  voucher: vouchers_obj_rel_insert_input
  voucher_address: String
}

"""aggregate max on columns"""
type transactions_max_fields {
  block_number: Int
  date_block: timestamp
  id: Int
  recipient_address: String
  sender_address: String
  tx_hash: String
  tx_index: Int
  tx_value: bigint
  voucher_address: String
}

"""
order by max() on columns of table "transactions"
"""
input transactions_max_order_by {
  block_number: order_by
  date_block: order_by
  id: order_by
  recipient_address: order_by
  sender_address: order_by
  tx_hash: order_by
  tx_index: order_by
  tx_value: order_by
  voucher_address: order_by
}

"""aggregate min on columns"""
type transactions_min_fields {
  block_number: Int
  date_block: timestamp
  id: Int
  recipient_address: String
  sender_address: String
  tx_hash: String
  tx_index: Int
  tx_value: bigint
  voucher_address: String
}

"""
order by min() on columns of table "transactions"
"""
input transactions_min_order_by {
  block_number: order_by
  date_block: order_by
  id: order_by
  recipient_address: order_by
  sender_address: order_by
  tx_hash: order_by
  tx_index: order_by
  tx_value: order_by
  voucher_address: order_by
}

"""
response of any mutation on the table "transactions"
"""
type transactions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [transactions!]!
}

"""
on_conflict condition type for table "transactions"
"""
input transactions_on_conflict {
  constraint: transactions_constraint!
  update_columns: [transactions_update_column!]! = []
  where: transactions_bool_exp
}

"""Ordering options when selecting data from "transactions"."""
input transactions_order_by {
  block_number: order_by
  date_block: order_by
  id: order_by
  recipient_address: order_by
  sender_address: order_by
  success: order_by
  txTypeByTxType: tx_type_order_by
  tx_hash: order_by
  tx_index: order_by
  tx_type: order_by
  tx_value: order_by
  voucher: vouchers_order_by
  voucher_address: order_by
}

"""primary key columns input for table: transactions"""
input transactions_pk_columns_input {
  id: Int!
}

"""
select columns of table "transactions"
"""
enum transactions_select_column {
  """column name"""
  block_number

  """column name"""
  date_block

  """column name"""
  id

  """column name"""
  recipient_address

  """column name"""
  sender_address

  """column name"""
  success

  """column name"""
  tx_hash

  """column name"""
  tx_index

  """column name"""
  tx_type

  """column name"""
  tx_value

  """column name"""
  voucher_address
}

"""
select "transactions_aggregate_bool_exp_bool_and_arguments_columns" columns of table "transactions"
"""
enum transactions_select_column_transactions_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  success
}

"""
select "transactions_aggregate_bool_exp_bool_or_arguments_columns" columns of table "transactions"
"""
enum transactions_select_column_transactions_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  success
}

"""
input type for updating data in table "transactions"
"""
input transactions_set_input {
  block_number: Int
  date_block: timestamp
  recipient_address: String
  sender_address: String
  success: Boolean
  tx_hash: String
  tx_index: Int
  tx_type: tx_type_enum
  tx_value: bigint
  voucher_address: String
}

"""aggregate stddev on columns"""
type transactions_stddev_fields {
  block_number: Float
  id: Float
  tx_index: Float
  tx_value: Float
}

"""
order by stddev() on columns of table "transactions"
"""
input transactions_stddev_order_by {
  block_number: order_by
  id: order_by
  tx_index: order_by
  tx_value: order_by
}

"""aggregate stddev_pop on columns"""
type transactions_stddev_pop_fields {
  block_number: Float
  id: Float
  tx_index: Float
  tx_value: Float
}

"""
order by stddev_pop() on columns of table "transactions"
"""
input transactions_stddev_pop_order_by {
  block_number: order_by
  id: order_by
  tx_index: order_by
  tx_value: order_by
}

"""aggregate stddev_samp on columns"""
type transactions_stddev_samp_fields {
  block_number: Float
  id: Float
  tx_index: Float
  tx_value: Float
}

"""
order by stddev_samp() on columns of table "transactions"
"""
input transactions_stddev_samp_order_by {
  block_number: order_by
  id: order_by
  tx_index: order_by
  tx_value: order_by
}

"""
Streaming cursor of the table "transactions"
"""
input transactions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: transactions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input transactions_stream_cursor_value_input {
  block_number: Int
  date_block: timestamp
  id: Int
  recipient_address: String
  sender_address: String
  success: Boolean
  tx_hash: String
  tx_index: Int
  tx_type: tx_type_enum
  tx_value: bigint
  voucher_address: String
}

"""aggregate sum on columns"""
type transactions_sum_fields {
  block_number: Int
  id: Int
  tx_index: Int
  tx_value: bigint
}

"""
order by sum() on columns of table "transactions"
"""
input transactions_sum_order_by {
  block_number: order_by
  id: order_by
  tx_index: order_by
  tx_value: order_by
}

"""
update columns of table "transactions"
"""
enum transactions_update_column {
  """column name"""
  block_number

  """column name"""
  date_block

  """column name"""
  recipient_address

  """column name"""
  sender_address

  """column name"""
  success

  """column name"""
  tx_hash

  """column name"""
  tx_index

  """column name"""
  tx_type

  """column name"""
  tx_value

  """column name"""
  voucher_address
}

input transactions_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: transactions_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: transactions_set_input

  """filter the rows which have to be updated"""
  where: transactions_bool_exp!
}

"""aggregate var_pop on columns"""
type transactions_var_pop_fields {
  block_number: Float
  id: Float
  tx_index: Float
  tx_value: Float
}

"""
order by var_pop() on columns of table "transactions"
"""
input transactions_var_pop_order_by {
  block_number: order_by
  id: order_by
  tx_index: order_by
  tx_value: order_by
}

"""aggregate var_samp on columns"""
type transactions_var_samp_fields {
  block_number: Float
  id: Float
  tx_index: Float
  tx_value: Float
}

"""
order by var_samp() on columns of table "transactions"
"""
input transactions_var_samp_order_by {
  block_number: order_by
  id: order_by
  tx_index: order_by
  tx_value: order_by
}

"""aggregate variance on columns"""
type transactions_variance_fields {
  block_number: Float
  id: Float
  tx_index: Float
  tx_value: Float
}

"""
order by variance() on columns of table "transactions"
"""
input transactions_variance_order_by {
  block_number: order_by
  id: order_by
  tx_index: order_by
  tx_value: order_by
}

"""
columns and relationships of "tx_type"
"""
type tx_type {
  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): [transactions!]!

  """An aggregate relationship"""
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): transactions_aggregate!
  value: String!
}

"""
aggregated selection of "tx_type"
"""
type tx_type_aggregate {
  aggregate: tx_type_aggregate_fields
  nodes: [tx_type!]!
}

"""
aggregate fields of "tx_type"
"""
type tx_type_aggregate_fields {
  count(columns: [tx_type_select_column!], distinct: Boolean): Int!
  max: tx_type_max_fields
  min: tx_type_min_fields
}

"""
Boolean expression to filter rows from the table "tx_type". All fields are combined with a logical 'AND'.
"""
input tx_type_bool_exp {
  _and: [tx_type_bool_exp!]
  _not: tx_type_bool_exp
  _or: [tx_type_bool_exp!]
  transactions: transactions_bool_exp
  transactions_aggregate: transactions_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "tx_type"
"""
enum tx_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  tx_type_pkey
}

enum tx_type_enum {
  MINT_TO
  TRANSFER
  TRANSFER_FROM
}

"""
Boolean expression to compare columns of type "tx_type_enum". All fields are combined with logical 'AND'.
"""
input tx_type_enum_comparison_exp {
  _eq: tx_type_enum
  _in: [tx_type_enum!]
  _is_null: Boolean
  _neq: tx_type_enum
  _nin: [tx_type_enum!]
}

"""
input type for inserting data into table "tx_type"
"""
input tx_type_insert_input {
  transactions: transactions_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type tx_type_max_fields {
  value: String
}

"""aggregate min on columns"""
type tx_type_min_fields {
  value: String
}

"""
response of any mutation on the table "tx_type"
"""
type tx_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [tx_type!]!
}

"""
input type for inserting object relation for remote table "tx_type"
"""
input tx_type_obj_rel_insert_input {
  data: tx_type_insert_input!

  """upsert condition"""
  on_conflict: tx_type_on_conflict
}

"""
on_conflict condition type for table "tx_type"
"""
input tx_type_on_conflict {
  constraint: tx_type_constraint!
  update_columns: [tx_type_update_column!]! = []
  where: tx_type_bool_exp
}

"""Ordering options when selecting data from "tx_type"."""
input tx_type_order_by {
  transactions_aggregate: transactions_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: tx_type"""
input tx_type_pk_columns_input {
  value: String!
}

"""
select columns of table "tx_type"
"""
enum tx_type_select_column {
  """column name"""
  value
}

"""
input type for updating data in table "tx_type"
"""
input tx_type_set_input {
  value: String
}

"""
Streaming cursor of the table "tx_type"
"""
input tx_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: tx_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input tx_type_stream_cursor_value_input {
  value: String
}

"""
update columns of table "tx_type"
"""
enum tx_type_update_column {
  """column name"""
  value
}

input tx_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: tx_type_set_input

  """filter the rows which have to be updated"""
  where: tx_type_bool_exp!
}

"""
columns and relationships of "users"
"""
type users {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): accounts_aggregate!
  activated: Boolean
  created_at: timestamp!
  id: Int!

  """An object relationship"""
  interfaceTypeByInterfaceType: interface_type!
  interface_identifier: String!
  interface_type: interface_type_enum!

  """An object relationship"""
  personal_information: personal_information
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

input users_aggregate_bool_exp {
  bool_and: users_aggregate_bool_exp_bool_and
  bool_or: users_aggregate_bool_exp_bool_or
  count: users_aggregate_bool_exp_count
}

input users_aggregate_bool_exp_bool_and {
  arguments: users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_bool_or {
  arguments: users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_count {
  arguments: [users_select_column!]
  distinct: Boolean
  filter: users_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  avg: users_avg_fields
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
  stddev: users_stddev_fields
  stddev_pop: users_stddev_pop_fields
  stddev_samp: users_stddev_samp_fields
  sum: users_sum_fields
  var_pop: users_var_pop_fields
  var_samp: users_var_samp_fields
  variance: users_variance_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  avg: users_avg_order_by
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
  stddev: users_stddev_order_by
  stddev_pop: users_stddev_pop_order_by
  stddev_samp: users_stddev_samp_order_by
  sum: users_sum_order_by
  var_pop: users_var_pop_order_by
  var_samp: users_var_samp_order_by
  variance: users_variance_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""aggregate avg on columns"""
type users_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "users"
"""
input users_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  accounts: accounts_bool_exp
  accounts_aggregate: accounts_aggregate_bool_exp
  activated: Boolean_comparison_exp
  created_at: timestamp_comparison_exp
  id: Int_comparison_exp
  interfaceTypeByInterfaceType: interface_type_bool_exp
  interface_identifier: String_comparison_exp
  interface_type: interface_type_enum_comparison_exp
  personal_information: personal_information_bool_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "interface_identifier"
  """
  users_interface_identifier_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  accounts: accounts_arr_rel_insert_input
  activated: Boolean
  created_at: timestamp
  interfaceTypeByInterfaceType: interface_type_obj_rel_insert_input
  interface_identifier: String
  interface_type: interface_type_enum
  personal_information: personal_information_obj_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  created_at: timestamp
  id: Int
  interface_identifier: String
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  created_at: order_by
  id: order_by
  interface_identifier: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  created_at: timestamp
  id: Int
  interface_identifier: String
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  created_at: order_by
  id: order_by
  interface_identifier: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "users"."""
input users_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  activated: order_by
  created_at: order_by
  id: order_by
  interfaceTypeByInterfaceType: interface_type_order_by
  interface_identifier: order_by
  interface_type: order_by
  personal_information: personal_information_order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  id: Int!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  activated

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  interface_identifier

  """column name"""
  interface_type
}

"""
select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  activated
}

"""
select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  activated
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  activated: Boolean
  created_at: timestamp
  interface_identifier: String
  interface_type: interface_type_enum
}

"""aggregate stddev on columns"""
type users_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "users"
"""
input users_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type users_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "users"
"""
input users_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type users_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "users"
"""
input users_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  activated: Boolean
  created_at: timestamp
  id: Int
  interface_identifier: String
  interface_type: interface_type_enum
}

"""aggregate sum on columns"""
type users_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "users"
"""
input users_sum_order_by {
  id: order_by
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  activated

  """column name"""
  created_at

  """column name"""
  interface_identifier

  """column name"""
  interface_type
}

input users_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

"""aggregate var_pop on columns"""
type users_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "users"
"""
input users_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type users_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "users"
"""
input users_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type users_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "users"
"""
input users_variance_order_by {
  id: order_by
}

"""
columns and relationships of "voucher_backers"
"""
type voucher_backers {
  """An object relationship"""
  account: accounts!
  active: Boolean
  backer: Int!
  created_at: timestamp!
  id: Int!
  voucher: Int!

  """An object relationship"""
  voucherByVoucher: vouchers!
}

"""
aggregated selection of "voucher_backers"
"""
type voucher_backers_aggregate {
  aggregate: voucher_backers_aggregate_fields
  nodes: [voucher_backers!]!
}

input voucher_backers_aggregate_bool_exp {
  bool_and: voucher_backers_aggregate_bool_exp_bool_and
  bool_or: voucher_backers_aggregate_bool_exp_bool_or
  count: voucher_backers_aggregate_bool_exp_count
}

input voucher_backers_aggregate_bool_exp_bool_and {
  arguments: voucher_backers_select_column_voucher_backers_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: voucher_backers_bool_exp
  predicate: Boolean_comparison_exp!
}

input voucher_backers_aggregate_bool_exp_bool_or {
  arguments: voucher_backers_select_column_voucher_backers_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: voucher_backers_bool_exp
  predicate: Boolean_comparison_exp!
}

input voucher_backers_aggregate_bool_exp_count {
  arguments: [voucher_backers_select_column!]
  distinct: Boolean
  filter: voucher_backers_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "voucher_backers"
"""
type voucher_backers_aggregate_fields {
  avg: voucher_backers_avg_fields
  count(columns: [voucher_backers_select_column!], distinct: Boolean): Int!
  max: voucher_backers_max_fields
  min: voucher_backers_min_fields
  stddev: voucher_backers_stddev_fields
  stddev_pop: voucher_backers_stddev_pop_fields
  stddev_samp: voucher_backers_stddev_samp_fields
  sum: voucher_backers_sum_fields
  var_pop: voucher_backers_var_pop_fields
  var_samp: voucher_backers_var_samp_fields
  variance: voucher_backers_variance_fields
}

"""
order by aggregate values of table "voucher_backers"
"""
input voucher_backers_aggregate_order_by {
  avg: voucher_backers_avg_order_by
  count: order_by
  max: voucher_backers_max_order_by
  min: voucher_backers_min_order_by
  stddev: voucher_backers_stddev_order_by
  stddev_pop: voucher_backers_stddev_pop_order_by
  stddev_samp: voucher_backers_stddev_samp_order_by
  sum: voucher_backers_sum_order_by
  var_pop: voucher_backers_var_pop_order_by
  var_samp: voucher_backers_var_samp_order_by
  variance: voucher_backers_variance_order_by
}

"""
input type for inserting array relation for remote table "voucher_backers"
"""
input voucher_backers_arr_rel_insert_input {
  data: [voucher_backers_insert_input!]!

  """upsert condition"""
  on_conflict: voucher_backers_on_conflict
}

"""aggregate avg on columns"""
type voucher_backers_avg_fields {
  backer: Float
  id: Float
  voucher: Float
}

"""
order by avg() on columns of table "voucher_backers"
"""
input voucher_backers_avg_order_by {
  backer: order_by
  id: order_by
  voucher: order_by
}

"""
Boolean expression to filter rows from the table "voucher_backers". All fields are combined with a logical 'AND'.
"""
input voucher_backers_bool_exp {
  _and: [voucher_backers_bool_exp!]
  _not: voucher_backers_bool_exp
  _or: [voucher_backers_bool_exp!]
  account: accounts_bool_exp
  active: Boolean_comparison_exp
  backer: Int_comparison_exp
  created_at: timestamp_comparison_exp
  id: Int_comparison_exp
  voucher: Int_comparison_exp
  voucherByVoucher: vouchers_bool_exp
}

"""
unique or primary key constraints on table "voucher_backers"
"""
enum voucher_backers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  voucher_backers_pkey
}

"""
input type for incrementing numeric columns in table "voucher_backers"
"""
input voucher_backers_inc_input {
  backer: Int
  voucher: Int
}

"""
input type for inserting data into table "voucher_backers"
"""
input voucher_backers_insert_input {
  account: accounts_obj_rel_insert_input
  active: Boolean
  backer: Int
  created_at: timestamp
  voucher: Int
  voucherByVoucher: vouchers_obj_rel_insert_input
}

"""aggregate max on columns"""
type voucher_backers_max_fields {
  backer: Int
  created_at: timestamp
  id: Int
  voucher: Int
}

"""
order by max() on columns of table "voucher_backers"
"""
input voucher_backers_max_order_by {
  backer: order_by
  created_at: order_by
  id: order_by
  voucher: order_by
}

"""aggregate min on columns"""
type voucher_backers_min_fields {
  backer: Int
  created_at: timestamp
  id: Int
  voucher: Int
}

"""
order by min() on columns of table "voucher_backers"
"""
input voucher_backers_min_order_by {
  backer: order_by
  created_at: order_by
  id: order_by
  voucher: order_by
}

"""
response of any mutation on the table "voucher_backers"
"""
type voucher_backers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [voucher_backers!]!
}

"""
on_conflict condition type for table "voucher_backers"
"""
input voucher_backers_on_conflict {
  constraint: voucher_backers_constraint!
  update_columns: [voucher_backers_update_column!]! = []
  where: voucher_backers_bool_exp
}

"""Ordering options when selecting data from "voucher_backers"."""
input voucher_backers_order_by {
  account: accounts_order_by
  active: order_by
  backer: order_by
  created_at: order_by
  id: order_by
  voucher: order_by
  voucherByVoucher: vouchers_order_by
}

"""primary key columns input for table: voucher_backers"""
input voucher_backers_pk_columns_input {
  id: Int!
}

"""
select columns of table "voucher_backers"
"""
enum voucher_backers_select_column {
  """column name"""
  active

  """column name"""
  backer

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  voucher
}

"""
select "voucher_backers_aggregate_bool_exp_bool_and_arguments_columns" columns of table "voucher_backers"
"""
enum voucher_backers_select_column_voucher_backers_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  active
}

"""
select "voucher_backers_aggregate_bool_exp_bool_or_arguments_columns" columns of table "voucher_backers"
"""
enum voucher_backers_select_column_voucher_backers_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  active
}

"""
input type for updating data in table "voucher_backers"
"""
input voucher_backers_set_input {
  active: Boolean
  backer: Int
  created_at: timestamp
  voucher: Int
}

"""aggregate stddev on columns"""
type voucher_backers_stddev_fields {
  backer: Float
  id: Float
  voucher: Float
}

"""
order by stddev() on columns of table "voucher_backers"
"""
input voucher_backers_stddev_order_by {
  backer: order_by
  id: order_by
  voucher: order_by
}

"""aggregate stddev_pop on columns"""
type voucher_backers_stddev_pop_fields {
  backer: Float
  id: Float
  voucher: Float
}

"""
order by stddev_pop() on columns of table "voucher_backers"
"""
input voucher_backers_stddev_pop_order_by {
  backer: order_by
  id: order_by
  voucher: order_by
}

"""aggregate stddev_samp on columns"""
type voucher_backers_stddev_samp_fields {
  backer: Float
  id: Float
  voucher: Float
}

"""
order by stddev_samp() on columns of table "voucher_backers"
"""
input voucher_backers_stddev_samp_order_by {
  backer: order_by
  id: order_by
  voucher: order_by
}

"""
Streaming cursor of the table "voucher_backers"
"""
input voucher_backers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: voucher_backers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input voucher_backers_stream_cursor_value_input {
  active: Boolean
  backer: Int
  created_at: timestamp
  id: Int
  voucher: Int
}

"""aggregate sum on columns"""
type voucher_backers_sum_fields {
  backer: Int
  id: Int
  voucher: Int
}

"""
order by sum() on columns of table "voucher_backers"
"""
input voucher_backers_sum_order_by {
  backer: order_by
  id: order_by
  voucher: order_by
}

"""
update columns of table "voucher_backers"
"""
enum voucher_backers_update_column {
  """column name"""
  active

  """column name"""
  backer

  """column name"""
  created_at

  """column name"""
  voucher
}

input voucher_backers_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: voucher_backers_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: voucher_backers_set_input

  """filter the rows which have to be updated"""
  where: voucher_backers_bool_exp!
}

"""aggregate var_pop on columns"""
type voucher_backers_var_pop_fields {
  backer: Float
  id: Float
  voucher: Float
}

"""
order by var_pop() on columns of table "voucher_backers"
"""
input voucher_backers_var_pop_order_by {
  backer: order_by
  id: order_by
  voucher: order_by
}

"""aggregate var_samp on columns"""
type voucher_backers_var_samp_fields {
  backer: Float
  id: Float
  voucher: Float
}

"""
order by var_samp() on columns of table "voucher_backers"
"""
input voucher_backers_var_samp_order_by {
  backer: order_by
  id: order_by
  voucher: order_by
}

"""aggregate variance on columns"""
type voucher_backers_variance_fields {
  backer: Float
  id: Float
  voucher: Float
}

"""
order by variance() on columns of table "voucher_backers"
"""
input voucher_backers_variance_order_by {
  backer: order_by
  id: order_by
  voucher: order_by
}

"""
columns and relationships of "voucher_certifications"
"""
type voucher_certifications {
  """An object relationship"""
  account: accounts!
  certificate_url_pointer: String!
  certifier: Int!
  certifier_weight: numeric!
  created_at: timestamp!
  id: Int!
  voucher: Int!

  """An object relationship"""
  voucherByVoucher: vouchers!
}

"""
aggregated selection of "voucher_certifications"
"""
type voucher_certifications_aggregate {
  aggregate: voucher_certifications_aggregate_fields
  nodes: [voucher_certifications!]!
}

input voucher_certifications_aggregate_bool_exp {
  count: voucher_certifications_aggregate_bool_exp_count
}

input voucher_certifications_aggregate_bool_exp_count {
  arguments: [voucher_certifications_select_column!]
  distinct: Boolean
  filter: voucher_certifications_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "voucher_certifications"
"""
type voucher_certifications_aggregate_fields {
  avg: voucher_certifications_avg_fields
  count(columns: [voucher_certifications_select_column!], distinct: Boolean): Int!
  max: voucher_certifications_max_fields
  min: voucher_certifications_min_fields
  stddev: voucher_certifications_stddev_fields
  stddev_pop: voucher_certifications_stddev_pop_fields
  stddev_samp: voucher_certifications_stddev_samp_fields
  sum: voucher_certifications_sum_fields
  var_pop: voucher_certifications_var_pop_fields
  var_samp: voucher_certifications_var_samp_fields
  variance: voucher_certifications_variance_fields
}

"""
order by aggregate values of table "voucher_certifications"
"""
input voucher_certifications_aggregate_order_by {
  avg: voucher_certifications_avg_order_by
  count: order_by
  max: voucher_certifications_max_order_by
  min: voucher_certifications_min_order_by
  stddev: voucher_certifications_stddev_order_by
  stddev_pop: voucher_certifications_stddev_pop_order_by
  stddev_samp: voucher_certifications_stddev_samp_order_by
  sum: voucher_certifications_sum_order_by
  var_pop: voucher_certifications_var_pop_order_by
  var_samp: voucher_certifications_var_samp_order_by
  variance: voucher_certifications_variance_order_by
}

"""
input type for inserting array relation for remote table "voucher_certifications"
"""
input voucher_certifications_arr_rel_insert_input {
  data: [voucher_certifications_insert_input!]!

  """upsert condition"""
  on_conflict: voucher_certifications_on_conflict
}

"""aggregate avg on columns"""
type voucher_certifications_avg_fields {
  certifier: Float
  certifier_weight: Float
  id: Float
  voucher: Float
}

"""
order by avg() on columns of table "voucher_certifications"
"""
input voucher_certifications_avg_order_by {
  certifier: order_by
  certifier_weight: order_by
  id: order_by
  voucher: order_by
}

"""
Boolean expression to filter rows from the table "voucher_certifications". All fields are combined with a logical 'AND'.
"""
input voucher_certifications_bool_exp {
  _and: [voucher_certifications_bool_exp!]
  _not: voucher_certifications_bool_exp
  _or: [voucher_certifications_bool_exp!]
  account: accounts_bool_exp
  certificate_url_pointer: String_comparison_exp
  certifier: Int_comparison_exp
  certifier_weight: numeric_comparison_exp
  created_at: timestamp_comparison_exp
  id: Int_comparison_exp
  voucher: Int_comparison_exp
  voucherByVoucher: vouchers_bool_exp
}

"""
unique or primary key constraints on table "voucher_certifications"
"""
enum voucher_certifications_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  voucher_certifications_pkey
}

"""
input type for incrementing numeric columns in table "voucher_certifications"
"""
input voucher_certifications_inc_input {
  certifier: Int
  certifier_weight: numeric
  voucher: Int
}

"""
input type for inserting data into table "voucher_certifications"
"""
input voucher_certifications_insert_input {
  account: accounts_obj_rel_insert_input
  certificate_url_pointer: String
  certifier: Int
  certifier_weight: numeric
  created_at: timestamp
  voucher: Int
  voucherByVoucher: vouchers_obj_rel_insert_input
}

"""aggregate max on columns"""
type voucher_certifications_max_fields {
  certificate_url_pointer: String
  certifier: Int
  certifier_weight: numeric
  created_at: timestamp
  id: Int
  voucher: Int
}

"""
order by max() on columns of table "voucher_certifications"
"""
input voucher_certifications_max_order_by {
  certificate_url_pointer: order_by
  certifier: order_by
  certifier_weight: order_by
  created_at: order_by
  id: order_by
  voucher: order_by
}

"""aggregate min on columns"""
type voucher_certifications_min_fields {
  certificate_url_pointer: String
  certifier: Int
  certifier_weight: numeric
  created_at: timestamp
  id: Int
  voucher: Int
}

"""
order by min() on columns of table "voucher_certifications"
"""
input voucher_certifications_min_order_by {
  certificate_url_pointer: order_by
  certifier: order_by
  certifier_weight: order_by
  created_at: order_by
  id: order_by
  voucher: order_by
}

"""
response of any mutation on the table "voucher_certifications"
"""
type voucher_certifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [voucher_certifications!]!
}

"""
on_conflict condition type for table "voucher_certifications"
"""
input voucher_certifications_on_conflict {
  constraint: voucher_certifications_constraint!
  update_columns: [voucher_certifications_update_column!]! = []
  where: voucher_certifications_bool_exp
}

"""Ordering options when selecting data from "voucher_certifications"."""
input voucher_certifications_order_by {
  account: accounts_order_by
  certificate_url_pointer: order_by
  certifier: order_by
  certifier_weight: order_by
  created_at: order_by
  id: order_by
  voucher: order_by
  voucherByVoucher: vouchers_order_by
}

"""primary key columns input for table: voucher_certifications"""
input voucher_certifications_pk_columns_input {
  id: Int!
}

"""
select columns of table "voucher_certifications"
"""
enum voucher_certifications_select_column {
  """column name"""
  certificate_url_pointer

  """column name"""
  certifier

  """column name"""
  certifier_weight

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  voucher
}

"""
input type for updating data in table "voucher_certifications"
"""
input voucher_certifications_set_input {
  certificate_url_pointer: String
  certifier: Int
  certifier_weight: numeric
  created_at: timestamp
  voucher: Int
}

"""aggregate stddev on columns"""
type voucher_certifications_stddev_fields {
  certifier: Float
  certifier_weight: Float
  id: Float
  voucher: Float
}

"""
order by stddev() on columns of table "voucher_certifications"
"""
input voucher_certifications_stddev_order_by {
  certifier: order_by
  certifier_weight: order_by
  id: order_by
  voucher: order_by
}

"""aggregate stddev_pop on columns"""
type voucher_certifications_stddev_pop_fields {
  certifier: Float
  certifier_weight: Float
  id: Float
  voucher: Float
}

"""
order by stddev_pop() on columns of table "voucher_certifications"
"""
input voucher_certifications_stddev_pop_order_by {
  certifier: order_by
  certifier_weight: order_by
  id: order_by
  voucher: order_by
}

"""aggregate stddev_samp on columns"""
type voucher_certifications_stddev_samp_fields {
  certifier: Float
  certifier_weight: Float
  id: Float
  voucher: Float
}

"""
order by stddev_samp() on columns of table "voucher_certifications"
"""
input voucher_certifications_stddev_samp_order_by {
  certifier: order_by
  certifier_weight: order_by
  id: order_by
  voucher: order_by
}

"""
Streaming cursor of the table "voucher_certifications"
"""
input voucher_certifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: voucher_certifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input voucher_certifications_stream_cursor_value_input {
  certificate_url_pointer: String
  certifier: Int
  certifier_weight: numeric
  created_at: timestamp
  id: Int
  voucher: Int
}

"""aggregate sum on columns"""
type voucher_certifications_sum_fields {
  certifier: Int
  certifier_weight: numeric
  id: Int
  voucher: Int
}

"""
order by sum() on columns of table "voucher_certifications"
"""
input voucher_certifications_sum_order_by {
  certifier: order_by
  certifier_weight: order_by
  id: order_by
  voucher: order_by
}

"""
update columns of table "voucher_certifications"
"""
enum voucher_certifications_update_column {
  """column name"""
  certificate_url_pointer

  """column name"""
  certifier

  """column name"""
  certifier_weight

  """column name"""
  created_at

  """column name"""
  voucher
}

input voucher_certifications_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: voucher_certifications_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: voucher_certifications_set_input

  """filter the rows which have to be updated"""
  where: voucher_certifications_bool_exp!
}

"""aggregate var_pop on columns"""
type voucher_certifications_var_pop_fields {
  certifier: Float
  certifier_weight: Float
  id: Float
  voucher: Float
}

"""
order by var_pop() on columns of table "voucher_certifications"
"""
input voucher_certifications_var_pop_order_by {
  certifier: order_by
  certifier_weight: order_by
  id: order_by
  voucher: order_by
}

"""aggregate var_samp on columns"""
type voucher_certifications_var_samp_fields {
  certifier: Float
  certifier_weight: Float
  id: Float
  voucher: Float
}

"""
order by var_samp() on columns of table "voucher_certifications"
"""
input voucher_certifications_var_samp_order_by {
  certifier: order_by
  certifier_weight: order_by
  id: order_by
  voucher: order_by
}

"""aggregate variance on columns"""
type voucher_certifications_variance_fields {
  certifier: Float
  certifier_weight: Float
  id: Float
  voucher: Float
}

"""
order by variance() on columns of table "voucher_certifications"
"""
input voucher_certifications_variance_order_by {
  certifier: order_by
  certifier_weight: order_by
  id: order_by
  voucher: order_by
}

"""
columns and relationships of "vouchers"
"""
type vouchers {
  active: Boolean
  created_at: timestamp!
  demurrage_rate: numeric!
  geo: point
  id: Int!
  location_name: String

  """An array relationship"""
  service_accepted_payments(
    """distinct select on columns"""
    distinct_on: [service_accepted_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_accepted_payment_order_by!]

    """filter the rows returned"""
    where: service_accepted_payment_bool_exp
  ): [service_accepted_payment!]!

  """An aggregate relationship"""
  service_accepted_payments_aggregate(
    """distinct select on columns"""
    distinct_on: [service_accepted_payment_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [service_accepted_payment_order_by!]

    """filter the rows returned"""
    where: service_accepted_payment_bool_exp
  ): service_accepted_payment_aggregate!
  sink_address: String!
  supply: Int!
  symbol: String!

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): [transactions!]!

  """An aggregate relationship"""
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): transactions_aggregate!
  voucher_address: String!

  """An array relationship"""
  voucher_backers(
    """distinct select on columns"""
    distinct_on: [voucher_backers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_backers_order_by!]

    """filter the rows returned"""
    where: voucher_backers_bool_exp
  ): [voucher_backers!]!

  """An aggregate relationship"""
  voucher_backers_aggregate(
    """distinct select on columns"""
    distinct_on: [voucher_backers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_backers_order_by!]

    """filter the rows returned"""
    where: voucher_backers_bool_exp
  ): voucher_backers_aggregate!

  """An array relationship"""
  voucher_certifications(
    """distinct select on columns"""
    distinct_on: [voucher_certifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_certifications_order_by!]

    """filter the rows returned"""
    where: voucher_certifications_bool_exp
  ): [voucher_certifications!]!

  """An aggregate relationship"""
  voucher_certifications_aggregate(
    """distinct select on columns"""
    distinct_on: [voucher_certifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [voucher_certifications_order_by!]

    """filter the rows returned"""
    where: voucher_certifications_bool_exp
  ): voucher_certifications_aggregate!
  voucher_description: String!
  voucher_name: String!
}

"""
aggregated selection of "vouchers"
"""
type vouchers_aggregate {
  aggregate: vouchers_aggregate_fields
  nodes: [vouchers!]!
}

"""
aggregate fields of "vouchers"
"""
type vouchers_aggregate_fields {
  avg: vouchers_avg_fields
  count(columns: [vouchers_select_column!], distinct: Boolean): Int!
  max: vouchers_max_fields
  min: vouchers_min_fields
  stddev: vouchers_stddev_fields
  stddev_pop: vouchers_stddev_pop_fields
  stddev_samp: vouchers_stddev_samp_fields
  sum: vouchers_sum_fields
  var_pop: vouchers_var_pop_fields
  var_samp: vouchers_var_samp_fields
  variance: vouchers_variance_fields
}

"""aggregate avg on columns"""
type vouchers_avg_fields {
  demurrage_rate: Float
  id: Float
  supply: Float
}

"""
Boolean expression to filter rows from the table "vouchers". All fields are combined with a logical 'AND'.
"""
input vouchers_bool_exp {
  _and: [vouchers_bool_exp!]
  _not: vouchers_bool_exp
  _or: [vouchers_bool_exp!]
  active: Boolean_comparison_exp
  created_at: timestamp_comparison_exp
  demurrage_rate: numeric_comparison_exp
  geo: point_comparison_exp
  id: Int_comparison_exp
  location_name: String_comparison_exp
  service_accepted_payments: service_accepted_payment_bool_exp
  service_accepted_payments_aggregate: service_accepted_payment_aggregate_bool_exp
  sink_address: String_comparison_exp
  supply: Int_comparison_exp
  symbol: String_comparison_exp
  transactions: transactions_bool_exp
  transactions_aggregate: transactions_aggregate_bool_exp
  voucher_address: String_comparison_exp
  voucher_backers: voucher_backers_bool_exp
  voucher_backers_aggregate: voucher_backers_aggregate_bool_exp
  voucher_certifications: voucher_certifications_bool_exp
  voucher_certifications_aggregate: voucher_certifications_aggregate_bool_exp
  voucher_description: String_comparison_exp
  voucher_name: String_comparison_exp
}

"""
unique or primary key constraints on table "vouchers"
"""
enum vouchers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  vouchers_pkey

  """
  unique or primary key constraint on columns "voucher_address"
  """
  vouchers_voucher_address_key
}

"""
input type for incrementing numeric columns in table "vouchers"
"""
input vouchers_inc_input {
  demurrage_rate: numeric
  supply: Int
}

"""
input type for inserting data into table "vouchers"
"""
input vouchers_insert_input {
  active: Boolean
  created_at: timestamp
  demurrage_rate: numeric
  geo: point
  location_name: String
  service_accepted_payments: service_accepted_payment_arr_rel_insert_input
  sink_address: String
  supply: Int
  symbol: String
  transactions: transactions_arr_rel_insert_input
  voucher_address: String
  voucher_backers: voucher_backers_arr_rel_insert_input
  voucher_certifications: voucher_certifications_arr_rel_insert_input
  voucher_description: String
  voucher_name: String
}

"""aggregate max on columns"""
type vouchers_max_fields {
  created_at: timestamp
  demurrage_rate: numeric
  id: Int
  location_name: String
  sink_address: String
  supply: Int
  symbol: String
  voucher_address: String
  voucher_description: String
  voucher_name: String
}

"""aggregate min on columns"""
type vouchers_min_fields {
  created_at: timestamp
  demurrage_rate: numeric
  id: Int
  location_name: String
  sink_address: String
  supply: Int
  symbol: String
  voucher_address: String
  voucher_description: String
  voucher_name: String
}

"""
response of any mutation on the table "vouchers"
"""
type vouchers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [vouchers!]!
}

"""
input type for inserting object relation for remote table "vouchers"
"""
input vouchers_obj_rel_insert_input {
  data: vouchers_insert_input!

  """upsert condition"""
  on_conflict: vouchers_on_conflict
}

"""
on_conflict condition type for table "vouchers"
"""
input vouchers_on_conflict {
  constraint: vouchers_constraint!
  update_columns: [vouchers_update_column!]! = []
  where: vouchers_bool_exp
}

"""Ordering options when selecting data from "vouchers"."""
input vouchers_order_by {
  active: order_by
  created_at: order_by
  demurrage_rate: order_by
  geo: order_by
  id: order_by
  location_name: order_by
  service_accepted_payments_aggregate: service_accepted_payment_aggregate_order_by
  sink_address: order_by
  supply: order_by
  symbol: order_by
  transactions_aggregate: transactions_aggregate_order_by
  voucher_address: order_by
  voucher_backers_aggregate: voucher_backers_aggregate_order_by
  voucher_certifications_aggregate: voucher_certifications_aggregate_order_by
  voucher_description: order_by
  voucher_name: order_by
}

"""primary key columns input for table: vouchers"""
input vouchers_pk_columns_input {
  id: Int!
}

"""
select columns of table "vouchers"
"""
enum vouchers_select_column {
  """column name"""
  active

  """column name"""
  created_at

  """column name"""
  demurrage_rate

  """column name"""
  geo

  """column name"""
  id

  """column name"""
  location_name

  """column name"""
  sink_address

  """column name"""
  supply

  """column name"""
  symbol

  """column name"""
  voucher_address

  """column name"""
  voucher_description

  """column name"""
  voucher_name
}

"""
input type for updating data in table "vouchers"
"""
input vouchers_set_input {
  active: Boolean
  created_at: timestamp
  demurrage_rate: numeric
  geo: point
  location_name: String
  sink_address: String
  supply: Int
  symbol: String
  voucher_address: String
  voucher_description: String
  voucher_name: String
}

"""aggregate stddev on columns"""
type vouchers_stddev_fields {
  demurrage_rate: Float
  id: Float
  supply: Float
}

"""aggregate stddev_pop on columns"""
type vouchers_stddev_pop_fields {
  demurrage_rate: Float
  id: Float
  supply: Float
}

"""aggregate stddev_samp on columns"""
type vouchers_stddev_samp_fields {
  demurrage_rate: Float
  id: Float
  supply: Float
}

"""
Streaming cursor of the table "vouchers"
"""
input vouchers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: vouchers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input vouchers_stream_cursor_value_input {
  active: Boolean
  created_at: timestamp
  demurrage_rate: numeric
  geo: point
  id: Int
  location_name: String
  sink_address: String
  supply: Int
  symbol: String
  voucher_address: String
  voucher_description: String
  voucher_name: String
}

"""aggregate sum on columns"""
type vouchers_sum_fields {
  demurrage_rate: numeric
  id: Int
  supply: Int
}

"""
update columns of table "vouchers"
"""
enum vouchers_update_column {
  """column name"""
  active

  """column name"""
  created_at

  """column name"""
  demurrage_rate

  """column name"""
  geo

  """column name"""
  location_name

  """column name"""
  sink_address

  """column name"""
  supply

  """column name"""
  symbol

  """column name"""
  voucher_address

  """column name"""
  voucher_description

  """column name"""
  voucher_name
}

input vouchers_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: vouchers_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: vouchers_set_input

  """filter the rows which have to be updated"""
  where: vouchers_bool_exp!
}

"""aggregate var_pop on columns"""
type vouchers_var_pop_fields {
  demurrage_rate: Float
  id: Float
  supply: Float
}

"""aggregate var_samp on columns"""
type vouchers_var_samp_fields {
  demurrage_rate: Float
  id: Float
  supply: Float
}

"""aggregate variance on columns"""
type vouchers_variance_fields {
  demurrage_rate: Float
  id: Float
  supply: Float
}

"""
columns and relationships of "vpa"
"""
type vpa {
  """An object relationship"""
  account: accounts!
  created_at: timestamp!
  id: Int!
  linked_account: Int!
  vpa: String!
}

"""
aggregated selection of "vpa"
"""
type vpa_aggregate {
  aggregate: vpa_aggregate_fields
  nodes: [vpa!]!
}

input vpa_aggregate_bool_exp {
  count: vpa_aggregate_bool_exp_count
}

input vpa_aggregate_bool_exp_count {
  arguments: [vpa_select_column!]
  distinct: Boolean
  filter: vpa_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "vpa"
"""
type vpa_aggregate_fields {
  avg: vpa_avg_fields
  count(columns: [vpa_select_column!], distinct: Boolean): Int!
  max: vpa_max_fields
  min: vpa_min_fields
  stddev: vpa_stddev_fields
  stddev_pop: vpa_stddev_pop_fields
  stddev_samp: vpa_stddev_samp_fields
  sum: vpa_sum_fields
  var_pop: vpa_var_pop_fields
  var_samp: vpa_var_samp_fields
  variance: vpa_variance_fields
}

"""
order by aggregate values of table "vpa"
"""
input vpa_aggregate_order_by {
  avg: vpa_avg_order_by
  count: order_by
  max: vpa_max_order_by
  min: vpa_min_order_by
  stddev: vpa_stddev_order_by
  stddev_pop: vpa_stddev_pop_order_by
  stddev_samp: vpa_stddev_samp_order_by
  sum: vpa_sum_order_by
  var_pop: vpa_var_pop_order_by
  var_samp: vpa_var_samp_order_by
  variance: vpa_variance_order_by
}

"""
input type for inserting array relation for remote table "vpa"
"""
input vpa_arr_rel_insert_input {
  data: [vpa_insert_input!]!

  """upsert condition"""
  on_conflict: vpa_on_conflict
}

"""aggregate avg on columns"""
type vpa_avg_fields {
  id: Float
  linked_account: Float
}

"""
order by avg() on columns of table "vpa"
"""
input vpa_avg_order_by {
  id: order_by
  linked_account: order_by
}

"""
Boolean expression to filter rows from the table "vpa". All fields are combined with a logical 'AND'.
"""
input vpa_bool_exp {
  _and: [vpa_bool_exp!]
  _not: vpa_bool_exp
  _or: [vpa_bool_exp!]
  account: accounts_bool_exp
  created_at: timestamp_comparison_exp
  id: Int_comparison_exp
  linked_account: Int_comparison_exp
  vpa: String_comparison_exp
}

"""
unique or primary key constraints on table "vpa"
"""
enum vpa_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  vpa_pkey

  """
  unique or primary key constraint on columns "vpa"
  """
  vpa_vpa_key
}

"""
input type for incrementing numeric columns in table "vpa"
"""
input vpa_inc_input {
  linked_account: Int
}

"""
input type for inserting data into table "vpa"
"""
input vpa_insert_input {
  account: accounts_obj_rel_insert_input
  created_at: timestamp
  linked_account: Int
  vpa: String
}

"""aggregate max on columns"""
type vpa_max_fields {
  created_at: timestamp
  id: Int
  linked_account: Int
  vpa: String
}

"""
order by max() on columns of table "vpa"
"""
input vpa_max_order_by {
  created_at: order_by
  id: order_by
  linked_account: order_by
  vpa: order_by
}

"""aggregate min on columns"""
type vpa_min_fields {
  created_at: timestamp
  id: Int
  linked_account: Int
  vpa: String
}

"""
order by min() on columns of table "vpa"
"""
input vpa_min_order_by {
  created_at: order_by
  id: order_by
  linked_account: order_by
  vpa: order_by
}

"""
response of any mutation on the table "vpa"
"""
type vpa_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [vpa!]!
}

"""
on_conflict condition type for table "vpa"
"""
input vpa_on_conflict {
  constraint: vpa_constraint!
  update_columns: [vpa_update_column!]! = []
  where: vpa_bool_exp
}

"""Ordering options when selecting data from "vpa"."""
input vpa_order_by {
  account: accounts_order_by
  created_at: order_by
  id: order_by
  linked_account: order_by
  vpa: order_by
}

"""primary key columns input for table: vpa"""
input vpa_pk_columns_input {
  id: Int!
}

"""
select columns of table "vpa"
"""
enum vpa_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  linked_account

  """column name"""
  vpa
}

"""
input type for updating data in table "vpa"
"""
input vpa_set_input {
  created_at: timestamp
  linked_account: Int
  vpa: String
}

"""aggregate stddev on columns"""
type vpa_stddev_fields {
  id: Float
  linked_account: Float
}

"""
order by stddev() on columns of table "vpa"
"""
input vpa_stddev_order_by {
  id: order_by
  linked_account: order_by
}

"""aggregate stddev_pop on columns"""
type vpa_stddev_pop_fields {
  id: Float
  linked_account: Float
}

"""
order by stddev_pop() on columns of table "vpa"
"""
input vpa_stddev_pop_order_by {
  id: order_by
  linked_account: order_by
}

"""aggregate stddev_samp on columns"""
type vpa_stddev_samp_fields {
  id: Float
  linked_account: Float
}

"""
order by stddev_samp() on columns of table "vpa"
"""
input vpa_stddev_samp_order_by {
  id: order_by
  linked_account: order_by
}

"""
Streaming cursor of the table "vpa"
"""
input vpa_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: vpa_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input vpa_stream_cursor_value_input {
  created_at: timestamp
  id: Int
  linked_account: Int
  vpa: String
}

"""aggregate sum on columns"""
type vpa_sum_fields {
  id: Int
  linked_account: Int
}

"""
order by sum() on columns of table "vpa"
"""
input vpa_sum_order_by {
  id: order_by
  linked_account: order_by
}

"""
update columns of table "vpa"
"""
enum vpa_update_column {
  """column name"""
  created_at

  """column name"""
  linked_account

  """column name"""
  vpa
}

input vpa_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: vpa_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: vpa_set_input

  """filter the rows which have to be updated"""
  where: vpa_bool_exp!
}

"""aggregate var_pop on columns"""
type vpa_var_pop_fields {
  id: Float
  linked_account: Float
}

"""
order by var_pop() on columns of table "vpa"
"""
input vpa_var_pop_order_by {
  id: order_by
  linked_account: order_by
}

"""aggregate var_samp on columns"""
type vpa_var_samp_fields {
  id: Float
  linked_account: Float
}

"""
order by var_samp() on columns of table "vpa"
"""
input vpa_var_samp_order_by {
  id: order_by
  linked_account: order_by
}

"""aggregate variance on columns"""
type vpa_variance_fields {
  id: Float
  linked_account: Float
}

"""
order by variance() on columns of table "vpa"
"""
input vpa_variance_order_by {
  id: order_by
  linked_account: order_by
}

